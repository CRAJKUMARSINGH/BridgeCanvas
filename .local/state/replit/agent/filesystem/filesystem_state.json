{"file_contents":{"app.py":{"content":"import os\nimport logging\nfrom flask import Flask, render_template, request, redirect, url_for, flash, send_file, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom werkzeug.utils import secure_filename\nfrom bridge_processor import BridgeProcessor\nimport traceback\n\n# Set up logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\n# create the app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"dev-secret-key-change-in-production\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# configure the database\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\", \"sqlite:///bridge_designs.db\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n\n# File upload configuration\napp.config['UPLOAD_FOLDER'] = 'uploads'\napp.config['GENERATED_FOLDER'] = 'generated'\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size\n\nALLOWED_EXTENSIONS = {'xlsx', 'xls'}\n\n# Ensure upload and generated directories exist\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\nos.makedirs(app.config['GENERATED_FOLDER'], exist_ok=True)\n\n# initialize the app with the extension\ndb.init_app(app)\n\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    try:\n        if 'file' not in request.files:\n            flash('No file selected', 'error')\n            return redirect(url_for('index'))\n        \n        file = request.files['file']\n        if file.filename == '':\n            flash('No file selected', 'error')\n            return redirect(url_for('index'))\n        \n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n            file.save(filepath)\n            \n            # Process the bridge design\n            processor = BridgeProcessor()\n            try:\n                results = processor.process_excel_file(filepath)\n                \n                # Store results in session or database for retrieval\n                # For simplicity, we'll pass directly to results page\n                return render_template('results.html', \n                                     results=results, \n                                     filename=filename)\n                \n            except Exception as e:\n                app.logger.error(f\"Processing error: {str(e)}\")\n                app.logger.error(traceback.format_exc())\n                flash(f'Error processing file: {str(e)}', 'error')\n                return redirect(url_for('index'))\n        else:\n            flash('Invalid file type. Please upload an Excel file (.xlsx or .xls)', 'error')\n            return redirect(url_for('index'))\n            \n    except Exception as e:\n        app.logger.error(f\"Upload error: {str(e)}\")\n        flash('An error occurred during file upload', 'error')\n        return redirect(url_for('index'))\n\n@app.route('/download/<filename>')\ndef download_file(filename):\n    try:\n        file_path = os.path.join(app.config['GENERATED_FOLDER'], filename)\n        if os.path.exists(file_path):\n            return send_file(file_path, as_attachment=True)\n        else:\n            flash('File not found', 'error')\n            return redirect(url_for('index'))\n    except Exception as e:\n        app.logger.error(f\"Download error: {str(e)}\")\n        flash('Error downloading file', 'error')\n        return redirect(url_for('index'))\n\n@app.route('/validate', methods=['POST'])\ndef validate_parameters():\n    \"\"\"AJAX endpoint for parameter validation\"\"\"\n    try:\n        data = request.get_json()\n        processor = BridgeProcessor()\n        validation_result = processor.validate_parameters(data)\n        return jsonify(validation_result)\n    except Exception as e:\n        return jsonify({'valid': False, 'errors': [str(e)]})\n\n@app.errorhandler(413)\ndef too_large(e):\n    flash('File is too large. Maximum size is 16MB.', 'error')\n    return redirect(url_for('index'))\n\n@app.errorhandler(500)\ndef internal_error(e):\n    app.logger.error(f\"Internal server error: {str(e)}\")\n    flash('An internal error occurred. Please try again.', 'error')\n    return redirect(url_for('index'))\n\nwith app.app_context():\n    import models\n    db.create_all()\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":4688},"bridge_processor.py":{"content":"import pandas as pd\nimport ezdxf\nimport os\nimport math\nfrom datetime import datetime\nimport logging\n\nclass BridgeProcessor:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.required_variables = [\n            'SCALE1', 'SCALE2', 'SKEW', 'DATUM', 'TOPRL', 'LEFT', 'RIGHT', 'XINCR', 'YINCR', 'NOCH',\n            'NSPAN', 'LBRIDGE', 'ABTL', 'RTL', 'SOFL', 'KERBW', 'KERBD', 'CCBR', 'SLBTHC', 'SLBTHE',\n            'SLBTHT', 'CAPT', 'CAPB', 'CAPW', 'PIERTW', 'BATTR', 'PIERST', 'PIERN', 'SPAN1', 'FUTRL',\n            'FUTD', 'FUTW', 'FUTL', 'DWTH', 'ALCW', 'ALCD', 'ALFB', 'ALFBL', 'ALTB', 'ALTBL', 'ALFO',\n            'ALBB', 'ALBBL', 'ABTLEN', 'LASLAB', 'APWTH', 'APTHK', 'WCTH', 'ALFL', 'ARFL', 'ALFBR',\n            'ALTBR', 'ALFD', 'ALBBR'\n        ]\n    \n    def process_excel_file(self, filepath):\n        \"\"\"Process Excel file and generate bridge drawings\"\"\"\n        try:\n            # Read Excel file\n            df = self.read_variables(filepath)\n            if df is None:\n                raise ValueError(\"Could not read Excel file\")\n            \n            # Validate parameters\n            validation_result = self.validate_dataframe(df)\n            if not validation_result['valid']:\n                raise ValueError(f\"Parameter validation failed: {'; '.join(validation_result['errors'])}\")\n            \n            # Extract variables\n            variables = self.extract_variables(df)\n            \n            # Generate DXF file\n            dxf_filename = self.generate_dxf(variables)\n            \n            # Generate SVG for web display\n            svg_content = self.generate_svg_preview(variables)\n            \n            return {\n                'success': True,\n                'variables': variables,\n                'dxf_filename': dxf_filename,\n                'svg_content': svg_content,\n                'validation': validation_result\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Processing error: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e),\n                'variables': {},\n                'dxf_filename': None,\n                'svg_content': None\n            }\n    \n    def read_variables(self, file_path):\n        \"\"\"Read variables from Excel file\"\"\"\n        try:\n            # Read Excel file without headers first\n            df = pd.read_excel(file_path, header=None)\n            \n            # Check if first row contains headers\n            if (df.iloc[0, 0] == 'Value' and df.iloc[0, 1] == 'Variable'):\n                # Skip header row and set proper column names\n                df = df.iloc[1:].reset_index(drop=True)\n                df.columns = ['Value', 'Variable', 'Description'] if df.shape[1] >= 3 else ['Value', 'Variable']\n            else:\n                # No headers, set column names directly\n                if df.shape[1] >= 3:\n                    df.columns = ['Value', 'Variable', 'Description']\n                elif df.shape[1] == 2:\n                    df.columns = ['Value', 'Variable']\n                else:\n                    raise ValueError(\"Excel file must have at least 2 columns\")\n            \n            # Add description column if missing\n            if 'Description' not in df.columns:\n                df['Description'] = ''\n                \n            return df\n        except Exception as e:\n            self.logger.error(f\"Error reading Excel file: {e}\")\n            return None\n    \n    def validate_dataframe(self, df):\n        \"\"\"Validate that all required variables are present\"\"\"\n        errors = []\n        missing_vars = []\n        \n        if 'Variable' not in df.columns:\n            return {'valid': False, 'errors': ['Excel file must have a Variable column']}\n        \n        # Check for required variables\n        present_vars = df['Variable'].tolist()\n        for var in self.required_variables:\n            if var not in present_vars:\n                missing_vars.append(var)\n        \n        if missing_vars:\n            errors.append(f\"Missing required variables: {', '.join(missing_vars)}\")\n        \n        # Check for numeric values\n        for index, row in df.iterrows():\n            try:\n                float(row['Value'])\n            except (ValueError, TypeError):\n                errors.append(f\"Non-numeric value for variable {row['Variable']}: {row['Value']}\")\n        \n        return {'valid': len(errors) == 0, 'errors': errors}\n    \n    def validate_parameters(self, parameters):\n        \"\"\"Validate individual parameters\"\"\"\n        errors = []\n        \n        # Basic validation rules\n        validations = {\n            'SCALE1': lambda x: x > 0,\n            'SCALE2': lambda x: x > 0,\n            'SKEW': lambda x: -45 <= x <= 45,\n            'NSPAN': lambda x: x >= 1 and x == int(x),\n            'NOCH': lambda x: x >= 2 and x == int(x),\n            'LBRIDGE': lambda x: x > 0,\n            'CCBR': lambda x: x > 0,\n        }\n        \n        for param, validation_func in validations.items():\n            if param in parameters:\n                try:\n                    value = float(parameters[param])\n                    if not validation_func(value):\n                        errors.append(f\"Invalid value for {param}: {value}\")\n                except (ValueError, TypeError):\n                    errors.append(f\"Non-numeric value for {param}\")\n        \n        return {'valid': len(errors) == 0, 'errors': errors}\n    \n    def extract_variables(self, df):\n        \"\"\"Extract variables from dataframe into dictionary\"\"\"\n        variables = {}\n        for index, row in df.iterrows():\n            try:\n                variables[row['Variable'].lower()] = float(row['Value'])\n            except (ValueError, TypeError):\n                self.logger.warning(f\"Could not convert {row['Variable']} value to float: {row['Value']}\")\n        return variables\n    \n    def generate_dxf(self, variables):\n        \"\"\"Generate DXF file from bridge parameters using comprehensive bridge drawing logic\"\"\"\n        try:\n            # Create DXF document\n            doc = ezdxf.new(\"R2010\", setup=True)\n            msp = doc.modelspace()\n            \n            # Setup styles and dimensions\n            self.setup_styles(doc)\n            \n            # Calculate derived values like the original code\n            scale1 = variables.get('scale1', 186)\n            scale2 = variables.get('scale2', 1)\n            skew = variables.get('skew', 0)\n            datum = variables.get('datum', 95)\n            left = variables.get('left', 0)\n            right = variables.get('right', 100)\n            toprl = variables.get('toprl', 100)\n            \n            # Scale calculations\n            hs = 1\n            vs = 1\n            sc = scale1 / scale2\n            vvs = 1000.0 / vs\n            hhs = 1000.0 / hs\n            skew1 = skew * 0.0174532  # Convert to radians\n            \n            # Position calculation functions\n            def vpos(a):\n                return datum + vvs * (a - datum)\n            \n            def hpos(a):\n                return left + hhs * (a - left)\n            \n            # Draw comprehensive bridge design using original logic\n            self.draw_layout_grid(msp, doc, variables, hpos, vpos, scale1, datum, left, toprl)\n            self.draw_bridge_superstructure(msp, variables, hpos, vpos, scale1, hhs)\n            self.draw_abutments_detailed(msp, variables, hpos, vpos, scale1)\n            self.draw_piers_detailed(msp, variables, hpos, vpos, scale1, hhs)\n            self.draw_approach_slabs(msp, variables, hpos, vpos, scale1)\n            \n            # Draw plan view (top-down view) with footings and plan details\n            self.draw_plan_view(msp, variables, hpos, vpos, scale1, hhs, vvs, datum, left)\n            \n            # Save DXF file\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"bridge_design_{timestamp}.dxf\"\n            \n            # Ensure generated directory exists (absolute path)\n            generated_dir = os.path.abspath(\"generated\")\n            os.makedirs(generated_dir, exist_ok=True)\n            filepath = os.path.join(generated_dir, filename)\n            doc.saveas(filepath)\n            \n            return filename\n            \n        except Exception as e:\n            self.logger.error(f\"DXF generation error: {str(e)}\")\n            raise\n    \n    def setup_styles(self, doc):\n        \"\"\"Setup DXF styles and dimension styles\"\"\"\n        try:\n            # Set up text style\n            doc.styles.new(\"Arial\", dxfattribs={'font': 'Arial.ttf'})\n            \n            # Set up dimension style\n            dimstyle = doc.dimstyles.new('PMB100')\n            dimstyle.dxf.dimasz = 150\n            dimstyle.dxf.dimtdec = 0\n            dimstyle.dxf.dimexe = 400\n            dimstyle.dxf.dimexo = 400\n            dimstyle.dxf.dimlfac = 1\n            dimstyle.dxf.dimtxsty = \"Arial\"\n            dimstyle.dxf.dimtxt = 400\n            dimstyle.dxf.dimtad = 0\n        except Exception as e:\n            self.logger.warning(f\"Style setup warning: {str(e)}\")\n    \n    def draw_bridge_elevation(self, msp, variables, sc, skew1):\n        \"\"\"Draw bridge elevation view\"\"\"\n        try:\n            datum = variables.get('datum', 0)\n            left = variables.get('left', 0)\n            lbridge = variables.get('lbridge', 100)\n            toprl = variables.get('toprl', 100)\n            sofl = variables.get('sofl', 95)\n            \n            # Draw main bridge outline\n            bridge_points = [\n                (left, sofl),\n                (left + lbridge, sofl),\n                (left + lbridge, toprl),\n                (left, toprl),\n                (left, sofl)\n            ]\n            \n            for i in range(len(bridge_points) - 1):\n                msp.add_line(bridge_points[i], bridge_points[i + 1])\n            \n            # Draw abutments\n            self.draw_abutments(msp, variables)\n            \n            # Draw piers if multiple spans\n            nspan = int(variables.get('nspan', 1))\n            if nspan > 1:\n                self.draw_piers(msp, variables, nspan)\n                \n        except Exception as e:\n            self.logger.error(f\"Elevation drawing error: {str(e)}\")\n    \n    def draw_abutments(self, msp, variables):\n        \"\"\"Draw abutment details\"\"\"\n        try:\n            left = variables.get('left', 0)\n            right = variables.get('right', 100)\n            datum = variables.get('datum', 0)\n            abtlen = variables.get('abtlen', 10)\n            alcw = variables.get('alcw', 5)\n            alcd = variables.get('alcd', 3)\n            \n            # Left abutment\n            left_abt_points = [\n                (left - abtlen, datum),\n                (left, datum),\n                (left, datum + alcd),\n                (left - alcw, datum + alcd),\n                (left - abtlen, datum)\n            ]\n            \n            for i in range(len(left_abt_points) - 1):\n                msp.add_line(left_abt_points[i], left_abt_points[i + 1])\n            \n            # Right abutment (mirror of left)\n            right_abt_points = [\n                (right + abtlen, datum),\n                (right, datum),\n                (right, datum + alcd),\n                (right + alcw, datum + alcd),\n                (right + abtlen, datum)\n            ]\n            \n            for i in range(len(right_abt_points) - 1):\n                msp.add_line(right_abt_points[i], right_abt_points[i + 1])\n                \n        except Exception as e:\n            self.logger.error(f\"Abutment drawing error: {str(e)}\")\n    \n    def draw_piers(self, msp, variables, nspan):\n        \"\"\"Draw pier details\"\"\"\n        try:\n            left = variables.get('left', 0)\n            lbridge = variables.get('lbridge', 100)\n            span1 = variables.get('span1', lbridge / nspan)\n            datum = variables.get('datum', 0)\n            capw = variables.get('capw', 5)\n            capt = variables.get('capt', 100)\n            capb = variables.get('capb', 95)\n            \n            # Draw piers between spans\n            for i in range(1, nspan):\n                pier_x = left + (i * span1)\n                \n                # Pier cap\n                cap_points = [\n                    (pier_x - capw/2, capb),\n                    (pier_x + capw/2, capb),\n                    (pier_x + capw/2, capt),\n                    (pier_x - capw/2, capt),\n                    (pier_x - capw/2, capb)\n                ]\n                \n                for j in range(len(cap_points) - 1):\n                    msp.add_line(cap_points[j], cap_points[j + 1])\n                \n                # Pier column\n                piertw = variables.get('piertw', 2)\n                msp.add_line((pier_x - piertw/2, capb), (pier_x - piertw/2, datum))\n                msp.add_line((pier_x + piertw/2, capb), (pier_x + piertw/2, datum))\n                \n        except Exception as e:\n            self.logger.error(f\"Pier drawing error: {str(e)}\")\n    \n    def draw_bridge_plan(self, msp, variables, sc, skew1):\n        \"\"\"Draw bridge plan view\"\"\"\n        try:\n            # Offset plan view vertically\n            plan_offset = -200\n            \n            left = variables.get('left', 0)\n            lbridge = variables.get('lbridge', 100)\n            ccbr = variables.get('ccbr', 20)\n            \n            # Draw bridge deck outline in plan\n            plan_points = [\n                (left, plan_offset - ccbr/2),\n                (left + lbridge, plan_offset - ccbr/2),\n                (left + lbridge, plan_offset + ccbr/2),\n                (left, plan_offset + ccbr/2),\n                (left, plan_offset - ccbr/2)\n            ]\n            \n            for i in range(len(plan_points) - 1):\n                msp.add_line(plan_points[i], plan_points[i + 1])\n                \n        except Exception as e:\n            self.logger.error(f\"Plan drawing error: {str(e)}\")\n    \n    def draw_layout_grid(self, msp, doc, variables, hpos, vpos, scale1, datum, left, toprl):\n        \"\"\"Draw layout grid and axes based on original code\"\"\"\n        try:\n            # Distance parameters\n            d1 = 20  # Distance in mm\n            xincr = variables.get('xincr', 5)\n            yincr = variables.get('yincr', 1)\n            right = variables.get('right', 100)\n            laslab = variables.get('laslab', 3.5)\n            \n            # Define grid points\n            pta1 = (left - laslab, datum)\n            pta2 = [hpos(variables.get('lbridge', 100) + laslab), datum]\n            ptb1 = (left, datum - d1 * scale1)\n            ptb2 = [hpos(right), datum - d1 * scale1]\n            ptc1 = [left, datum - 2 * d1 * scale1]\n            ptc2 = [hpos(right), datum - 2 * d1 * scale1]\n            ptd1 = [left, vpos(toprl)]\n            \n            # Draw X-axis and parallel lines\n            msp.add_line(pta1, pta2)\n            msp.add_line(ptb1, ptb2)\n            msp.add_line(ptc1, ptc2)\n            msp.add_line(ptc1, ptd1)  # Y-axis\n            \n            # Add text labels\n            ptb3 = (left - 25 * scale1, datum - d1 * 0.5 * scale1)\n            msp.add_text(\"BED LEVEL\", dxfattribs={'height': 2.5 * scale1, 'insert': ptb3})\n            ptb3 = (left - 25 * scale1, datum - d1 * 1.5 * scale1)\n            msp.add_text(\"CHAINAGE\", dxfattribs={'height': 2.5 * scale1, 'insert': ptb3})\n            \n            # Draw small lines on Y axis with levels\n            d2 = 2.5\n            small_line_start = (left - d2 * scale1, datum)\n            small_line_end = (left + d2 * scale1, datum)\n            msp.add_line(small_line_start, small_line_end)\n            \n            # Write levels on Y axis\n            nov = int((toprl - datum) // 1)\n            n = max(1, int(nov // yincr))\n            for a in range(n + 1):\n                lvl = datum + a * yincr\n                b1 = \"{:.3f}\".format(lvl)\n                pta1 = [left - 13 * scale1, vpos(lvl) - 1.0 * scale1]\n                text_height = 2.0 * scale1\n                msp.add_text(b1, dxfattribs={'height': text_height, 'rotation': 0, 'insert': pta1})\n                small_line_start = (left - d2 * scale1, vpos(lvl))\n                small_line_end = (left + d2 * scale1, vpos(lvl))\n                msp.add_line(small_line_start, small_line_end)\n            \n            # Write chainages on X axis\n            noh = right - left\n            n = int(noh // xincr)\n            d4 = 2 * d1\n            d5 = d4 - 2.0\n            d6 = d1 + 2.0\n            d7 = d1 - 2.0\n            d8 = d4 - 4.0\n            \n            for a in range(0, n + 2):\n                ch = left + a * xincr\n                b1 = f\"{ch:.3f}\"\n                pta1 = [scale1 + hpos(ch), datum - d8 * scale1]\n                msp.add_text(b1, dxfattribs={'height': 2.0 * scale1, 'insert': pta1, 'rotation': 90})\n                pta1 = [hpos(ch), datum - d4 * scale1]\n                pta2 = [hpos(ch), datum - d5 * scale1]\n                pta3 = [hpos(ch), datum - d6 * scale1]\n                pta4 = [hpos(ch), datum - d7 * scale1]\n                msp.add_line(pta1, pta2)\n                msp.add_line(pta3, pta4)\n                \n        except Exception as e:\n            self.logger.error(f\"Layout grid drawing error: {str(e)}\")\n    \n    def draw_bridge_superstructure(self, msp, variables, hpos, vpos, scale1, hhs):\n        \"\"\"Draw bridge superstructure with spans\"\"\"\n        try:\n            spans = variables.get('abtl', 0)\n            span1 = variables.get('span1', 30)\n            nspan = int(variables.get('nspan', 1))\n            rtl = variables.get('rtl', 100)\n            sofl = variables.get('sofl', 95)\n            \n            # Draw main spans\n            x1 = hpos(spans)\n            y1 = vpos(rtl)\n            x2 = hpos(spans + span1)\n            y2 = vpos(sofl)\n            \n            # Create base span rectangle\n            pta1 = [x1 + 25.0, y1]\n            pta2 = [x2 - 25.0, y2]\n            \n            # Draw first span\n            msp.add_lwpolyline([pta1, [pta2[0], pta1[1]], pta2, [pta1[0], pta2[1]], pta1], close=True)\n            \n            # Copy for additional spans\n            for i in range(1, nspan):\n                new_pta1 = [pta1[0] + i * span1 * hhs, pta1[1]]\n                new_pta2 = [pta2[0] + i * span1 * hhs, pta2[1]]\n                msp.add_lwpolyline([new_pta1, [new_pta2[0], new_pta1[1]], new_pta2, [new_pta1[0], new_pta2[1]], new_pta1], close=True)\n                \n        except Exception as e:\n            self.logger.error(f\"Superstructure drawing error: {str(e)}\")\n    \n    def draw_abutments_detailed(self, msp, variables, hpos, vpos, scale1):\n        \"\"\"Draw detailed abutments\"\"\"\n        try:\n            # Abutment parameters\n            abtl = variables.get('abtl', 0)\n            abtlen = variables.get('abtlen', 12)\n            alcw = variables.get('alcw', 0.75)\n            alcd = variables.get('alcd', 1.2)\n            dwth = variables.get('dwth', 0.3)\n            alfl = variables.get('alfl', 100)\n            alfb = variables.get('alfb', 10)\n            alfbl = variables.get('alfbl', 101)\n            altb = variables.get('altb', 10)\n            altbl = variables.get('altbl', 100.5)\n            alfo = variables.get('alfo', 0.5)\n            alfd = variables.get('alfd', 1.5)\n            albb = variables.get('albb', 5)\n            albbl = variables.get('albbl', 101.5)\n            lbridge = variables.get('lbridge', 100)\n            \n            # Left abutment\n            x1 = hpos(abtl - abtlen)\n            x2 = hpos(abtl)\n            y1 = vpos(alfl)\n            y2 = vpos(alfl + alcd)\n            \n            # Abutment cap\n            cap_points = [\n                [x1, y1],\n                [x2, y1],\n                [x2, y2],\n                [x1 + hpos(alcw) - hpos(0), y2],\n                [x1, y1]\n            ]\n            msp.add_lwpolyline(cap_points, close=True)\n            \n            # Front batter\n            front_batter_points = [\n                [x2, y2],\n                [x2, vpos(alfbl)],\n                [x2 + hpos(alfo) - hpos(0), vpos(altbl)],\n                [x2, vpos(altbl - alfd)],\n                [x1 + hpos(alcw) - hpos(0), vpos(altbl - alfd)],\n                [x1 + hpos(alcw) - hpos(0), y2]\n            ]\n            msp.add_lwpolyline(front_batter_points, close=True)\n            \n            # Right abutment (mirror)\n            right_x1 = hpos(abtl + lbridge)\n            right_x2 = hpos(abtl + lbridge + abtlen)\n            \n            right_cap_points = [\n                [right_x1, y1],\n                [right_x2, y1],\n                [right_x2, y2],\n                [right_x2 - hpos(alcw) + hpos(0), y2],\n                [right_x1, y1]\n            ]\n            msp.add_lwpolyline(right_cap_points, close=True)\n            \n        except Exception as e:\n            self.logger.error(f\"Abutment drawing error: {str(e)}\")\n    \n    def draw_piers_detailed(self, msp, variables, hpos, vpos, scale1, hhs):\n        \"\"\"Draw detailed piers with caps and footings\"\"\"\n        try:\n            nspan = int(variables.get('nspan', 1))\n            if nspan <= 1:\n                return  # No piers needed for single span\n                \n            abtl = variables.get('abtl', 0)\n            span1 = variables.get('span1', 30)\n            capw = variables.get('capw', 1.2)\n            capt = variables.get('capt', 100.5)\n            capb = variables.get('capb', 99.3)\n            piertw = variables.get('piertw', 0.6)\n            battr = variables.get('battr', 10)\n            pierst = variables.get('pierst', 5)\n            futrl = variables.get('futrl', 90)\n            futd = variables.get('futd', 2)\n            futw = variables.get('futw', 2.5)\n            futl = variables.get('futl', 3.5)\n            skew = variables.get('skew', 0)\n            \n            # Draw piers between spans\n            for i in range(1, nspan):\n                pier_chainage = abtl + i * span1\n                pier_x = hpos(pier_chainage)\n                \n                # Pier cap\n                cap_left = pier_x - hpos(capw/2) + hpos(0)\n                cap_right = pier_x + hpos(capw/2) - hpos(0)\n                cap_top = vpos(capt)\n                cap_bottom = vpos(capb)\n                \n                cap_points = [\n                    [cap_left, cap_bottom],\n                    [cap_right, cap_bottom],\n                    [cap_right, cap_top],\n                    [cap_left, cap_top],\n                    [cap_left, cap_bottom]\n                ]\n                msp.add_lwpolyline(cap_points, close=True)\n                \n                # Pier column with batter\n                pier_top_left = pier_x - hpos(piertw/2) + hpos(0)\n                pier_top_right = pier_x + hpos(piertw/2) - hpos(0)\n                pier_height = capb - futrl - futd\n                \n                # Calculate bottom width with batter\n                batter_expansion = pier_height / battr\n                pier_bottom_left = pier_top_left - hpos(batter_expansion) + hpos(0)\n                pier_bottom_right = pier_top_right + hpos(batter_expansion) - hpos(0)\n                \n                pier_points = [\n                    [pier_top_left, cap_bottom],\n                    [pier_top_right, cap_bottom],\n                    [pier_bottom_right, vpos(futrl + futd)],\n                    [pier_bottom_left, vpos(futrl + futd)],\n                    [pier_top_left, cap_bottom]\n                ]\n                msp.add_lwpolyline(pier_points, close=True)\n                \n                # Pier footing\n                footing_left = pier_x - hpos(futw/2) + hpos(0)\n                footing_right = pier_x + hpos(futw/2) - hpos(0)\n                footing_top = vpos(futrl + futd)\n                footing_bottom = vpos(futrl)\n                \n                footing_points = [\n                    [footing_left, footing_bottom],\n                    [footing_right, footing_bottom],\n                    [footing_right, footing_top],\n                    [footing_left, footing_top],\n                    [footing_left, footing_bottom]\n                ]\n                msp.add_lwpolyline(footing_points, close=True)\n                \n        except Exception as e:\n            self.logger.error(f\"Pier drawing error: {str(e)}\")\n    \n    def draw_approach_slabs(self, msp, variables, hpos, vpos, scale1):\n        \"\"\"Draw approach slabs\"\"\"\n        try:\n            abtl = variables.get('abtl', 0)\n            nspan = int(variables.get('nspan', 1))\n            span1 = variables.get('span1', 30)\n            laslab = variables.get('laslab', 3.5)\n            rtl = variables.get('rtl', 100)\n            apthk = variables.get('apthk', 0.23)\n            wcth = variables.get('wcth', 0.075)\n            \n            # Left approach slab\n            x1_left = hpos(abtl - laslab)\n            x2_left = hpos(abtl)\n            y1_left = vpos(rtl)\n            y2_left = vpos(rtl - apthk)\n            \n            left_slab_points = [\n                [x1_left, y1_left],\n                [x2_left, y1_left],\n                [x2_left, y2_left],\n                [x1_left, y2_left],\n                [x1_left, y1_left]\n            ]\n            msp.add_lwpolyline(left_slab_points, close=True)\n            \n            # Right approach slab\n            x1_right = hpos(abtl + (nspan * span1))\n            x2_right = hpos(abtl + (nspan * span1) + laslab)\n            y1_right = vpos(rtl)\n            y2_right = vpos(rtl - apthk)\n            \n            right_slab_points = [\n                [x1_right, y1_right],\n                [x2_right, y1_right],\n                [x2_right, y2_right],\n                [x1_right, y2_right],\n                [x1_right, y1_right]\n            ]\n            msp.add_lwpolyline(right_slab_points, close=True)\n            \n            # Wearing course (continuous across all slabs)\n            wearing_course_points = [\n                [x1_left, y1_left],\n                [x2_right, y1_right],\n                [x2_right, vpos(rtl + wcth)],\n                [x1_left, vpos(rtl + wcth)],\n                [x1_left, y1_left]\n            ]\n            msp.add_lwpolyline(wearing_course_points, close=True)\n            \n        except Exception as e:\n            self.logger.error(f\"Approach slab drawing error: {str(e)}\")\n    \n    def draw_plan_view(self, msp, variables, hpos, vpos, scale1, hhs, vvs, datum, left):\n        \"\"\"Draw comprehensive plan view with footings, abutments, and piers as per original logic\"\"\"\n        try:\n            # Get plan view variables\n            nspan = int(variables.get('nspan', 1))\n            span1 = variables.get('span1', 30)  \n            lspan = variables.get('lspan', span1)\n            abtl = variables.get('abtl', 0)\n            capw = variables.get('capw', 1.2)\n            piertw = variables.get('piertw', 0.6)\n            pierst = variables.get('pierst', 5)\n            futw = variables.get('futw', 2.5)\n            futl = variables.get('futl', 3.5)\n            futrl = variables.get('futrl', 90)\n            futd = variables.get('futd', 2)\n            sc = scale1 / variables.get('scale2', 1)\n            \n            # Plan view coordinate transformation functions (as per original)\n            def h2pos(a):\n                return left + sc * hhs * (a - left)\n            \n            def v2pos(a):\n                return datum + sc * vvs * (a - datum)\n            \n            def p2t(a, b):\n                \"\"\"Convert to plan view coordinates\"\"\"\n                aa = h2pos(a)\n                bb = v2pos(b)\n                return [aa, bb]\n            \n            # Offset for plan view positioning (below elevation view)\n            plan_offset_y = -5000  # Move plan view below elevation\n            \n            # Draw pier footings in plan view (as per original logic)\n            if nspan > 1:\n                self.draw_pier_footings_plan(msp, variables, h2pos, v2pos, p2t, plan_offset_y, nspan, lspan, hhs)\n            \n            # Draw abutment plans (left and right)\n            self.draw_abutment_plans(msp, variables, h2pos, v2pos, p2t, plan_offset_y, hhs, vvs, datum, left)\n            \n            # Draw bridge deck outline in plan\n            self.draw_bridge_deck_plan(msp, variables, h2pos, v2pos, p2t, plan_offset_y)\n            \n        except Exception as e:\n            self.logger.error(f\"Plan view drawing error: {str(e)}\")\n    \n    def draw_pier_footings_plan(self, msp, variables, h2pos, v2pos, p2t, plan_offset_y, nspan, lspan, hhs):\n        \"\"\"Draw pier footings in plan view as per original logic\"\"\"\n        try:\n            # Get footing parameters\n            abtl = variables.get('abtl', 0)\n            futw = variables.get('futw', 2.5)  # Footing width\n            futl = variables.get('futl', 3.5)  # Footing length\n            datum = variables.get('datum', 95)\n            \n            # Plan view footing coordinates (as per original)\n            yc = datum - 30.0\n            \n            # Draw footings for each pier\n            for i in range(1, nspan):\n                # Pier center position\n                xc = abtl + i * lspan\n                \n                # Footing corners in plan (as per original pt function logic)\n                x7 = xc - futw / 2  # Left edge of footing\n                x8 = x7 + futw      # Right edge of footing\n                y7 = yc + futl / 2  # Top edge of footing\n                y8 = y7 - futl      # Bottom edge of footing\n                \n                # Convert to plan coordinates with offset\n                pta7 = p2t(x7, y7)\n                pta8 = p2t(x8, y8)\n                pta7x = [pta7[0], pta8[1] + plan_offset_y]  # Bottom-left\n                pta8x = [pta8[0], pta7[1] + plan_offset_y]  # Top-right\n                pta7[1] += plan_offset_y  # Apply offset to top-left\n                pta8[1] += plan_offset_y  # Apply offset to bottom-right\n                \n                # Draw footing rectangle (as per original gr1-gr4 functions)\n                footing_points = [pta7, pta8x, pta8, pta7x, pta7]\n                msp.add_lwpolyline(footing_points, close=True)\n                \n                # Draw pier column outline in plan\n                pier_width = variables.get('piertw', 0.6)\n                pier_length = variables.get('pierst', 5)\n                \n                # Pier corners\n                pier_x1 = xc - pier_width / 2\n                pier_x2 = xc + pier_width / 2\n                pier_y1 = yc + pier_length / 2\n                pier_y2 = yc - pier_length / 2\n                \n                # Convert pier coordinates\n                pier_pt1 = p2t(pier_x1, pier_y1)\n                pier_pt2 = p2t(pier_x2, pier_y1)\n                pier_pt3 = p2t(pier_x2, pier_y2)\n                pier_pt4 = p2t(pier_x1, pier_y2)\n                \n                # Apply offset\n                pier_pt1[1] += plan_offset_y\n                pier_pt2[1] += plan_offset_y\n                pier_pt3[1] += plan_offset_y\n                pier_pt4[1] += plan_offset_y\n                \n                # Draw pier outline\n                pier_points = [pier_pt1, pier_pt2, pier_pt3, pier_pt4, pier_pt1]\n                msp.add_lwpolyline(pier_points, close=True)\n                \n        except Exception as e:\n            self.logger.error(f\"Pier footing plan drawing error: {str(e)}\")\n    \n    def draw_abutment_plans(self, msp, variables, h2pos, v2pos, p2t, plan_offset_y, hhs, vvs, datum, left):\n        \"\"\"Draw abutment plans (left and right) as per original abt1 and abt2 functions\"\"\"\n        try:\n            # Abutment parameters (as per original)\n            abtl = variables.get('abtl', 0)\n            abtlen = variables.get('abtlen', 12)\n            alcw = variables.get('alcw', 0.75)\n            alcd = variables.get('alcd', 1.2)\n            dwth = variables.get('dwth', 0.3)\n            lbridge = variables.get('lbridge', 100)\n            ccbr = variables.get('ccbr', 0.5)\n            kerbw = variables.get('kerbw', 0.3)\n            \n            # Plan view calculations (as per original abt1 function)\n            ccbrsq = ccbr / 1  # As per original c=1 \n            kerbwsq = kerbw / 1\n            abtlen_plan = ccbrsq + kerbwsq + kerbwsq\n            \n            yc = datum - 30.0\n            y20 = yc + (abtlen_plan / 2)   # D/S of abutment\n            y21 = y20 - abtlen_plan        # U/S of abutment  \n            y16 = y20 + 0.15               # D/S of footing\n            y17 = y21 - 0.15               # U/S of footing\n            \n            # Left abutment plan (as per original abt1)\n            x1 = abtl\n            alcwsq = alcw / 1\n            x3 = x1 + alcwsq\n            dwthsq = dwth / 1\n            x14 = x1 - dwthsq\n            \n            # Abutment footing points in plan\n            pt16 = p2t(x14, y16)  # Left footing corner\n            pt17 = p2t(x3, y16)   # Right footing corner  \n            pt18 = p2t(x3, y17)   # Right footing corner\n            pt19 = p2t(x14, y17)  # Left footing corner\n            \n            # Apply plan offset\n            pt16[1] += plan_offset_y\n            pt17[1] += plan_offset_y\n            pt18[1] += plan_offset_y\n            pt19[1] += plan_offset_y\n            \n            # Draw left abutment footing\n            left_abt_points = [pt16, pt17, pt18, pt19, pt16]\n            msp.add_lwpolyline(left_abt_points, close=True)\n            \n            # Right abutment plan (as per original abt2)  \n            right_edge = left + lbridge\n            x1_right = abtl\n            x3_right = x1_right + alcwsq\n            x14_right = x1_right - dwthsq\n            \n            # Right abutment footing points\n            pt20 = p2t(right_edge - x14_right, y16)  # Right footing corner\n            pt21 = p2t(right_edge - x3_right, y16)   # Left footing corner\n            pt22 = p2t(right_edge - x3_right, y17)   # Left footing corner\n            pt23 = p2t(right_edge - x14_right, y17)  # Right footing corner\n            \n            # Apply plan offset\n            pt20[1] += plan_offset_y\n            pt21[1] += plan_offset_y\n            pt22[1] += plan_offset_y\n            pt23[1] += plan_offset_y\n            \n            # Draw right abutment footing\n            right_abt_points = [pt20, pt21, pt22, pt23, pt20]\n            msp.add_lwpolyline(right_abt_points, close=True)\n            \n        except Exception as e:\n            self.logger.error(f\"Abutment plan drawing error: {str(e)}\")\n    \n    def draw_bridge_deck_plan(self, msp, variables, h2pos, v2pos, p2t, plan_offset_y):\n        \"\"\"Draw bridge deck outline in plan view\"\"\"\n        try:\n            # Bridge parameters\n            abtl = variables.get('abtl', 0)\n            lbridge = variables.get('lbridge', 100)\n            bridgew = variables.get('bridgew', 12)\n            datum = variables.get('datum', 95)\n            \n            # Plan coordinates for deck outline\n            yc = datum - 30.0\n            deck_width_half = bridgew / 2\n            \n            # Deck corners\n            deck_pt1 = p2t(abtl, yc + deck_width_half)          # Left-top\n            deck_pt2 = p2t(abtl + lbridge, yc + deck_width_half) # Right-top  \n            deck_pt3 = p2t(abtl + lbridge, yc - deck_width_half) # Right-bottom\n            deck_pt4 = p2t(abtl, yc - deck_width_half)          # Left-bottom\n            \n            # Apply plan offset\n            deck_pt1[1] += plan_offset_y\n            deck_pt2[1] += plan_offset_y\n            deck_pt3[1] += plan_offset_y\n            deck_pt4[1] += plan_offset_y\n            \n            # Draw deck outline\n            deck_points = [deck_pt1, deck_pt2, deck_pt3, deck_pt4, deck_pt1]\n            msp.add_lwpolyline(deck_points, close=True)\n            \n        except Exception as e:\n            self.logger.error(f\"Bridge deck plan drawing error: {str(e)}\")\n    \n    def generate_svg_preview(self, variables):\n        \"\"\"Generate SVG preview of the bridge design\"\"\"\n        try:\n            # SVG dimensions\n            width = 800\n            height = 600\n            \n            # Scale factors for display\n            display_scale = 2\n            \n            # Get key variables\n            left = variables.get('left', 0)\n            lbridge = variables.get('lbridge', 100)\n            datum = variables.get('datum', 0)\n            toprl = variables.get('toprl', 100)\n            sofl = variables.get('sofl', 95)\n            ccbr = variables.get('ccbr', 20)\n            \n            # Calculate display coordinates\n            bridge_width = lbridge * display_scale\n            bridge_height = (toprl - datum) * display_scale\n            \n            # Center the bridge in the SVG\n            offset_x = (width - bridge_width) / 2\n            offset_y = (height - bridge_height) / 2 - 100\n            \n            svg_content = f'''\n            <svg width=\"{width}\" height=\"{height}\" xmlns=\"http://www.w3.org/2000/svg\">\n                <defs>\n                    <style>\n                        .bridge-outline {{ fill: none; stroke: #007bff; stroke-width: 2; }}\n                        .abutment {{ fill: none; stroke: #28a745; stroke-width: 2; }}\n                        .pier {{ fill: none; stroke: #dc3545; stroke-width: 2; }}\n                        .text {{ font-family: Arial, sans-serif; font-size: 12px; fill: #333; }}\n                        .grid {{ stroke: #e0e0e0; stroke-width: 0.5; }}\n                    </style>\n                </defs>\n                \n                <!-- Grid -->\n                <defs>\n                    <pattern id=\"grid\" width=\"50\" height=\"50\" patternUnits=\"userSpaceOnUse\">\n                        <path d=\"M 50 0 L 0 0 0 50\" fill=\"none\" class=\"grid\"/>\n                    </pattern>\n                </defs>\n                <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\n                \n                <!-- Bridge elevation -->\n                <g transform=\"translate({offset_x}, {offset_y})\">\n                    <!-- Main bridge deck -->\n                    <rect x=\"0\" y=\"{(toprl - sofl) * display_scale}\" \n                          width=\"{bridge_width}\" height=\"{(toprl - sofl) * display_scale}\" \n                          class=\"bridge-outline\"/>\n                    \n                    <!-- Abutments -->\n                    <rect x=\"-20\" y=\"0\" width=\"20\" height=\"{bridge_height}\" class=\"abutment\"/>\n                    <rect x=\"{bridge_width}\" y=\"0\" width=\"20\" height=\"{bridge_height}\" class=\"abutment\"/>\n            '''\n            \n            # Add piers if multiple spans\n            nspan = int(variables.get('nspan', 1))\n            if nspan > 1:\n                span_width = bridge_width / nspan\n                for i in range(1, nspan):\n                    pier_x = i * span_width\n                    svg_content += f'''\n                    <rect x=\"{pier_x - 5}\" y=\"0\" width=\"10\" height=\"{bridge_height}\" class=\"pier\"/>\n                    '''\n            \n            # Add dimensions and labels\n            svg_content += f'''\n                    <!-- Labels -->\n                    <text x=\"{bridge_width/2}\" y=\"-10\" text-anchor=\"middle\" class=\"text\">\n                        Bridge Length: {lbridge:.1f}m\n                    </text>\n                    <text x=\"-50\" y=\"{bridge_height/2}\" text-anchor=\"middle\" class=\"text\" \n                          transform=\"rotate(-90, -50, {bridge_height/2})\">\n                        Height: {toprl - datum:.1f}m\n                    </text>\n                </g>\n                \n                <!-- Plan view -->\n                <g transform=\"translate({offset_x}, {height - 150})\">\n                    <text x=\"{bridge_width/2}\" y=\"-10\" text-anchor=\"middle\" class=\"text\">Plan View</text>\n                    <rect x=\"0\" y=\"0\" width=\"{bridge_width}\" height=\"{ccbr * display_scale}\" \n                          class=\"bridge-outline\"/>\n                    <text x=\"{bridge_width/2}\" y=\"{ccbr * display_scale + 20}\" text-anchor=\"middle\" class=\"text\">\n                        Width: {ccbr:.1f}m\n                    </text>\n                </g>\n                \n                <!-- Legend -->\n                <g transform=\"translate(20, 20)\">\n                    <text x=\"0\" y=\"0\" class=\"text\" style=\"font-weight: bold;\">Legend:</text>\n                    <line x1=\"0\" y1=\"15\" x2=\"20\" y2=\"15\" class=\"bridge-outline\"/>\n                    <text x=\"25\" y=\"20\" class=\"text\">Bridge Deck</text>\n                    <line x1=\"0\" y1=\"35\" x2=\"20\" y2=\"35\" class=\"abutment\"/>\n                    <text x=\"25\" y=\"40\" class=\"text\">Abutments</text>\n                    <line x1=\"0\" y1=\"55\" x2=\"20\" y2=\"55\" class=\"pier\"/>\n                    <text x=\"25\" y=\"60\" class=\"text\">Piers</text>\n                </g>\n            </svg>\n            '''\n            \n            return svg_content\n            \n        except Exception as e:\n            self.logger.error(f\"SVG generation error: {str(e)}\")\n            return f'<svg width=\"400\" height=\"200\"><text x=\"20\" y=\"100\">Error generating preview: {str(e)}</text></svg>'\n","size_bytes":40867},"main.py":{"content":"from app import app\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":99},"models.py":{"content":"from app import db\nfrom datetime import datetime\n\nclass BridgeDesign(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    filename = db.Column(db.String(255), nullable=False)\n    upload_time = db.Column(db.DateTime, default=datetime.utcnow)\n    parameters = db.Column(db.Text)  # JSON string of parameters\n    dxf_filename = db.Column(db.String(255))\n    status = db.Column(db.String(50), default='processing')\n    error_message = db.Column(db.Text)\n    \n    def __repr__(self):\n        return f'<BridgeDesign {self.filename}>'\n\nclass BridgeParameter(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    design_id = db.Column(db.Integer, db.ForeignKey('bridge_design.id'), nullable=False)\n    variable_name = db.Column(db.String(100), nullable=False)\n    value = db.Column(db.Float, nullable=False)\n    description = db.Column(db.String(255))\n    \n    design = db.relationship('BridgeDesign', backref=db.backref('parameters', lazy=True))\n","size_bytes":960},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"ezdxf>=1.4.2\",\n    \"flask>=3.1.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.1\",\n    \"psycopg2-binary>=2.9.10\",\n    \"sqlalchemy>=2.0.42\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":393},"replit.md":{"content":"# Bridge Design CAD Application\n\n## Overview\n\nThis is a Flask-based web application for processing bridge design parameters from Excel files and generating comprehensive CAD drawings in DXF format. The application takes Excel files containing bridge engineering parameters and converts them into detailed technical drawings including piers, abutments, approach slabs, and complete bridge geometry. It includes parameter validation, DXF generation capabilities, SVG preview functionality for web display, and an Excel template download for new users.\n\n## Recent Changes (August 3, 2025)\n\n✓ **Complete Bridge Drawing Logic**: Integrated comprehensive drawing methods from original source code including detailed pier drawing with caps, columns, and footings\n✓ **Excel Processing Fix**: Fixed header row handling and parameter validation for proper Excel file reading\n✓ **Plan View Implementation**: Added complete plan view drawings with footing plans, abutment plans, pier layouts, and bridge deck outline using original h2pos/v2pos coordinate systems\n✓ **DXF Generation**: Successfully generating 48KB DXF files with both elevation and plan views, complete bridge geometry, layout grids, and coordinate transformations\n✓ **Template System**: Created downloadable Excel template with 54 bridge parameters and descriptions for new users\n✓ **Web Interface Fix**: Resolved template rendering issues and added template download functionality\n✓ **SVG Preview**: Working bridge design preview with visual representation of generated CAD drawings\n\n**Latest Enhancement**: Restored missing abutments and added comprehensive plan view drawings as per original BridgeCanvas logic including pier footings, abutment plans with proper coordinate transformations.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Web Framework Architecture\n- **Flask-based MVC pattern**: Uses Flask as the primary web framework with template rendering for the frontend\n- **SQLAlchemy ORM**: Implements database abstraction layer with declarative base for model definitions\n- **File Upload Processing**: Handles Excel file uploads with validation and secure filename processing\n\n### Data Processing Pipeline\n- **Excel Parameter Extraction**: Reads bridge design parameters from uploaded Excel files using pandas\n- **Parameter Validation**: Validates required bridge engineering variables against a predefined schema\n- **CAD Generation**: Converts validated parameters into DXF format using ezdxf library for CAD compatibility\n- **Preview Generation**: Creates SVG representations for web-based preview of bridge designs\n\n### Database Design\n- **Bridge Design Storage**: Tracks uploaded files, processing status, and generated outputs\n- **Parameter Tracking**: Stores individual bridge parameters with relationships to design records\n- **File Management**: Maintains references to uploaded Excel files and generated DXF outputs\n\n### Frontend Architecture\n- **Bootstrap-based UI**: Uses Bootstrap with dark theme for responsive design\n- **Progressive Enhancement**: JavaScript handles file validation and form submission with progress indicators\n- **Template Inheritance**: Jinja2 templates with base template for consistent layout\n\n### File Management System\n- **Upload Directory Structure**: Segregated folders for uploads and generated files\n- **File Type Validation**: Restricts uploads to Excel formats (.xlsx, .xls) with size limits\n- **Secure Processing**: Uses werkzeug utilities for secure filename handling\n\n## External Dependencies\n\n### Core Framework Dependencies\n- **Flask**: Web application framework with SQLAlchemy integration\n- **pandas**: Excel file reading and data manipulation\n- **ezdxf**: DXF file generation for CAD output\n\n### Frontend Libraries\n- **Bootstrap**: UI component library with dark theme\n- **Font Awesome**: Icon library for interface elements\n\n### Database Options\n- **SQLite**: Default development database (configured via DATABASE_URL environment variable)\n- **PostgreSQL**: Production database support through SQLAlchemy configuration\n\n### Development Tools\n- **werkzeug**: WSGI utilities and development server\n- **ProxyFix**: Handles proxy headers for deployment environments\n\n### File Processing\n- **Secure file handling**: Built-in werkzeug utilities for filename sanitization\n- **Excel processing**: pandas for reading .xlsx and .xls files\n- **CAD output**: ezdxf for generating industry-standard DXF files","size_bytes":4490},"attached_assets/bridge_gad_app_1754197697460.py":{"content":"import math\r\nimport os\r\nimport pandas as pd\r\nimport ezdxf\r\nfrom ezdxf import *\r\nfrom ezdxf.entities import Line, Circle, Arc\r\nfrom math import atan2, degrees, sqrt, cos, sin, tan, radians, pi\r\n# Clear previously defined global variables\r\nfor var in list(globals().keys()):\r\n    if var.startswith('my_'):  # Use a common prefix for variables or filter by other criteria\r\n        del globals()[var]                \r\n# Define the add_text function\r\ndef add_text(text, insert, height, rotation):\r\n    doc.modelspace().add_text(text, dxfattribs={'height': height, 'insert': insert, 'rotation': rotation})\r\n# Create a DXF R2010 document and use default setup \r\ndoc = ezdxf.new(\"R2010\", setup=True)\r\nmsp = doc.modelspace()\r\n# Helper functions for drawing\r\ndef draw_line(msp, points):\r\n    for i in range(len(points) - 1):\r\n        msp.add_line(points[i], points[i + 1])\r\ndef draw_rectangle(msp, pt1, pt2):\r\n    msp.add_line(pt1, (pt2[0], pt1[1]))  # Bottom line\r\n    msp.add_line((pt2[0], pt1[1]), pt2)  # Right line\r\n    msp.add_line(pt2, (pt1[0], pt2[1]))  # Top line\r\n    msp.add_line((pt1[0], pt2[1]), pt1)  # Left line\r\n########################################################\r\n# File operations\r\ndef opn():\r\n    try:\r\n        directory = r\"F:\\LISP 2005\\P1\"\r\n        filename = \"input.xlsx\"\r\n        file_path = os.path.join(directory, filename)  # Define the file_path\r\n        f = open(file_path, \"r\")\r\n        print(\"\\nFile opened successfully.\")\r\n        return f\r\n    except FileNotFoundError:\r\n        print(\"\\nError: Could not open the file.\")\r\n        exit()\r\n#################################################\r\n# Read variables from Excel file\r\ndef read_variables(file_path):\r\n    try:\r\n        df = pd.read_excel(file_path, header=None)\r\n        df.columns = ['Value', 'Variable', 'Description']\r\n        return df\r\n    except Exception as e:\r\n        print(f\"Error reading Excel file: {e}\")\r\n        return None\r\n# Read variables from Excel file\r\nfile_path = r'F:\\LISP 2005\\P1\\input.xlsx'\r\ndf = read_variables(file_path)\r\nif df is not None:\r\n    # Print the first output of data read\r\n    print(df.head(1))\r\n    # Define variables\r\n    Scale1 = df.loc[df['Variable'] == 'SCALE1', 'Value'].values[0]\r\n    Scale2 = df.loc[df['Variable'] == 'SCALE2', 'Value'].values[0]    \r\n    skew = df.loc[df['Variable'] == 'SKEW', 'Value'].values[0]\r\n    # Calculate sc\r\n    sc = Scale1 / Scale2\r\n    print(f\"sc = {sc}\")\r\n    # Print variables\r\n    for index, row in df.iterrows():\r\n        print(f\"Variable: {row['Variable']}, Value: {row['Value']}\")\r\n#######################################   \r\n\r\n#######################################\r\ndef st(doc):\r\n    # Set up a style (font) in the document\r\n    # Note: ezdxf does not have direct control over many of these settings as AutoCAD does,\r\n    # so we'll focus on what we can control.\r\n    doc.styles.new(\"Arial\", dxfattribs={'font': 'Arial.ttf'})  # Assuming Arial.ttf is available\r\n    # Set up dimension style properties\r\n    dimstyle = doc.dimstyles.new('PMB100')\r\n    # Set dimension arrow size (DIMASZ)\r\n    dimstyle.dxf.dimasz = 150\r\n    # Set dimension decimal places (DIMDEC)\r\n    # This is not directly supported by ezdxf, but we can set precision for dimension texts\r\n    dimstyle.dxf.dimtdec = 0  # 0 decimal places\r\n    # Set dimension extension line extension (DIMEXE)\r\n    dimstyle.dxf.dimexe = 400\r\n    # Set dimension extension line offset (DIMEXO)\r\n    dimstyle.dxf.dimexo = 400    \r\n    # Set dimension scale factor (DIMLFAC)\r\n    dimstyle.dxf.dimlfac = 1   \r\n    # Set dimension text style (DIMTXSTY)\r\n    dimstyle.dxf.dimtxsty = \"Arial\"   \r\n    # Set dimension text height (DIMTXT)\r\n    dimstyle.dxf.dimtxt = 400   \r\n    # Set dimension text above dimension line (DIMTAD)\r\n    dimstyle.dxf.dimtad = 0  # 0 means below    \r\n    # Set dimension text inside extension linedef reed(f):\r\n    variables = [\r\n    'SCALE1', 'SCALE2', 'SKEW', 'DATUM', 'TOPRL', 'LEFT', 'RIGHT', 'XINCR', 'YINCR', 'NOCH',\r\n    'NSPAN', 'LBRIDGE', 'ABTL', 'RTL', 'SOFL', 'KERBW', 'KERBD', 'CCBR', 'SLBTHC', 'SLBTHE',\r\n    'SLBTHT', 'CAPT', 'CAPB', 'CAPW', 'PIERTW', 'BATTR', 'PIERST', 'PIERN', 'SPAN1', 'FUTRL',\r\n    'FUTD', 'FUTW', 'FUTL', 'DWTH', 'ALCW', 'ALCD', 'ALFB', 'ALFBL', 'ALTB', 'ALTBL', 'ALFO',\r\n    'ALBB', 'ALBBL', 'ABTLEN', 'laslab', 'APWTH', 'APTHK', 'WCTH'\r\n]\r\n    data = {}\r\n#########################################\r\n# Read variables from Excel file\r\n# Initialize the dictionary to store variable values\r\nvariable_values = {}\r\n# Populate the dictionary with unique variables\r\nif 'Variable' in df.columns:\r\n    variable_values['scale1'] = df.loc[df['Variable'] == 'SCALE1', 'Value'].values[0]  # Scale1\r\nelse:\r\n    print(\"Error: 'Variable' column not found in DataFrame\")\r\nvariable_values['scale1'] = df.loc[df['Variable'] == 'SCALE1', 'Value'].values[0]  # Scale1\r\nvariable_values['abtlen'] = df.loc[df['Variable'] == 'ABTLEN', 'Value'].values[0]  # Length of Abutment\r\nvariable_values['dwth'] = df.loc[df['Variable'] == 'DWTH', 'Value'].values[0]  # Dirtwall Thickness\r\nvariable_values['alcw'] = df.loc[df['Variable'] == 'ALCW', 'Value'].values[0]  # Abutment Left Cap Width Excluding D/W\r\nvariable_values['alfl'] = df.loc[df['Variable'] == 'ALFL', 'Value'].values[0]  # Abutment Left Footing Level\r\nvariable_values['arfl'] = df.loc[df['Variable'] == 'ARFL', 'Value'].values[0]  # Abutment Right Footing Level\r\nvariable_values['alcd'] = df.loc[df['Variable'] == 'ALCD', 'Value'].values[0]  # Abutment Left Cap Depth\r\nvariable_values['alfb'] = df.loc[df['Variable'] == 'ALFB', 'Value'].values[0]  # Abutment Left Front Batter\r\nvariable_values['alfbl'] = df.loc[df['Variable'] == 'ALFBL', 'Value'].values[0]  # Abutment Left Front Batter RL\r\nvariable_values['alfbr'] = df.loc[df['Variable'] == 'ALFBR', 'Value'].values[0]  # Abutment Right Front Batter RL\r\nvariable_values['altb'] = df.loc[df['Variable'] == 'ALTB', 'Value'].values[0]  # Abutment Left Toe Batter\r\nvariable_values['altbl'] = df.loc[df['Variable'] == 'ALTBL', 'Value'].values[0]  # Abutment Left Toe Batter Level Footing Top\r\nvariable_values['altbr'] = df.loc[df['Variable'] == 'ALTBR', 'Value'].values[0]  # Abutment Right Toe Batter Level Footing Top\r\nvariable_values['alfo'] = df.loc[df['Variable'] == 'ALFO', 'Value'].values[0]  # Abutment Left Front Offset To Footing\r\nvariable_values['alfd'] = df.loc[df['Variable'] == 'ALFD', 'Value'].values[0]  # Abutment Left Footing Depth\r\nvariable_values['albb'] = df.loc[df['Variable'] == 'ALBB', 'Value'].values[0]  # Abutment Left Back Batter\r\nvariable_values['albbl'] = df.loc[df['Variable'] == 'ALBBL', 'Value'].values[0]  # Abutment Left Back Batter RL\r\nvariable_values['albbr'] = df.loc[df['Variable'] == 'ALBBR', 'Value'].values[0]  # Abutment Right Back Batter RL\r\nvariable_values['scale2'] = df.loc[df['Variable'] == 'SCALE2', 'Value'].values[0]  # Scale2\r\nvariable_values['skew'] = df.loc[df['Variable'] == 'SKEW', 'Value'].values[0]  # Degree Of Skew\r\nvariable_values['datum'] = df.loc[df['Variable'] == 'DATUM', 'Value'].values[0]  # Datum\r\nvariable_values['toprl'] = df.loc[df['Variable'] == 'TOPRL', 'Value'].values[0]  # Top RL Of The Bridge\r\nvariable_values['left'] = df.loc[df['Variable'] == 'LEFT', 'Value'].values[0]  # Left Most Chainage\r\nvariable_values['right'] = df.loc[df['Variable'] == 'RIGHT', 'Value'].values[0]  # Right Most Chainage\r\nvariable_values['xincr'] = df.loc[df['Variable'] == 'XINCR', 'Value'].values[0]  # Chainage Increment In X Direction\r\nvariable_values['yincr'] = df.loc[df['Variable'] == 'YINCR', 'Value'].values[0]  # Elevation Increment In Y Direction\r\nvariable_values['noch'] = df.loc[df['Variable'] == 'NOCH', 'Value'].values[0]  # Total No. Of Chainages\r\nvariable_values['nspan'] = df.loc[df['Variable'] == 'NSPAN', 'Value'].values[0]  # Number of Spans\r\nvariable_values['lbridge'] = df.loc[df['Variable'] == 'LBRIDGE', 'Value'].values[0]  # Length Of Bridge\r\nvariable_values['abtl'] = df.loc[df['Variable'] == 'ABTL', 'Value'].values[0]  # Chainage Of Left Abutment\r\nvariable_values['rtl'] = df.loc[df['Variable'] == 'RTL', 'Value'].values[0]  # Road Top Level\r\nvariable_values['sofl'] = df.loc[df['Variable'] == 'SOFL', 'Value'].values[0]  # Soffit Level\r\nvariable_values['kerbw'] = df.loc[df['Variable'] == 'KERBW', 'Value'].values[0]  # Width Of Kerb\r\nvariable_values['kerbd'] = df.loc[df['Variable'] == 'KERBD', 'Value'].values[0]  # Depth Of Kerb\r\nvariable_values['ccbr'] = df.loc[df['Variable'] == 'CCBR', 'Value'].values[0]  # Clear Carriageway Width\r\nvariable_values['slbthc'] = df.loc[df['Variable'] == 'SLBTHC', 'Value'].values[0]  # Thickness Of Slab Centre\r\nvariable_values['slbthe'] = df.loc[df['Variable'] == 'SLBTHE', 'Value'].values[0]  # Thickness Of Slab Edge\r\nvariable_values['slbtht'] = df.loc[df['Variable'] == 'SLBTHT', 'Value'].values[0]  # Thickness Of Slab Tip\r\nvariable_values['capt'] = df.loc[df['Variable'] == 'CAPT', 'Value'].values[0]  # Pier Cap Top RL\r\nvariable_values['capb'] = df.loc[df['Variable'] == 'CAPB', 'Value'].values[0]  # Pier Cap Bottom RL\r\nvariable_values['capw'] = df.loc[df['Variable'] == 'CAPW', 'Value'].values[0]  # Cap Width\r\nvariable_values['piertw'] = df.loc[df['Variable'] == 'PIERTW', 'Value'].values[0]  # Pier Top Width\r\nvariable_values['battr'] = df.loc[df['Variable'] == 'BATTR', 'Value'].values[0]  # Pier Batter\r\nvariable_values['pierst'] = df.loc[df['Variable'] == 'PIERST', 'Value'].values[0]  # Straight Length Of Pier\r\nvariable_values['piern'] = df.loc[df['Variable'] == 'PIERN', 'Value'].values[0]  # Pier Sr No.\r\nvariable_values['span1'] = df.loc[df['Variable'] == 'SPAN1', 'Value'].values[0]  # Span Individual Length\r\nvariable_values['futrl'] = df.loc[df['Variable'] == 'FUTRL', 'Value'].values[0]  # Founding RL\r\nvariable_values['futd'] = df.loc[df['Variable'] == 'FUTD', 'Value'].values[0]  # Depth Of Footing\r\nvariable_values['futw'] = df.loc[df['Variable'] == 'FUTW', 'Value'].values[0]  # Width Of Footing\r\nvariable_values['futl'] = df.loc[df['Variable'] == 'FUTL', 'Value'].values[0]  # Length Of Footing\r\nvariable_values['laslab'] = df.loc[df['Variable'] == 'LASLAB', 'Value'].values[0]  # Length of Approach Slab\r\nvariable_values['apwth'] = df.loc[df['Variable'] == 'APWTH', 'Value'].values[0]  # Width of Approach Slab\r\nvariable_values['apthk'] = df.loc[df['Variable'] == 'APTHK', 'Value'].values[0]  # Thickness of Approach Slab\r\nvariable_values['wcth'] = df.loc[df['Variable'] == 'WCTH', 'Value'].values[0]  # Thickness of Wearing Course\r\n# Assigning variables from the dictionary\r\nfor key, value in variable_values.items():\r\n    globals()[key] = value  # Dynamically create global variables\r\nnspan = int(nspan)  # Convert dynamically if it's not already an integer\r\nnoch = int(noch)  # Convert dynamically if it's not already an integer\r\n####################################################\r\nimport math\r\n# Perform calculations\r\nhs = 1\r\nvs = 1\r\nsc = Scale1 / Scale2\r\nvvs = 1000.0 / vs\r\nhhs = 1000.0 / hs\r\nskew1 = skew * 0.0174532  # Convert degrees to radians\r\ns = math.sin(skew1)\r\nc = math.cos(skew1)\r\ntn = s / c\r\n# Print the computed values and the result of the sine, cosine, and tangent calculations\r\nprint(f\"vvs: {vvs}\")\r\nprint(f\"hhs: {hhs}\")\r\nprint(f\"skew1 (radians): {skew1}\")\r\nprint(f\"sin(skew1): {s}\")\r\nprint(f\"cos(skew1): {c}\")\r\nprint(f\"tan(skew1): {tn}\")\r\nprint(f\"sc: {sc}\")\r\n###############################################################\r\ndef vpos(a):\r\n    return datum + vvs * (a - datum)   \r\ndef hpos(a):\r\n    return left + hhs * (a - left)\r\ndef v2pos(a):\r\n    return datum + sc * vvs * (a - datum)\r\ndef h2pos(a):\r\n    return left + sc * hhs * (a - left)\r\n################################################################################################\r\n# 3.0 plotting layout of elevation ( X axis Y axis etc.) \r\n#############################################################\r\n##########################################\r\nleft = int(left)    \r\n    # Define distance between lines parallel to X axis\r\ndef turn_off_osnap(doc):\r\n    # Simulate saving the OSNAP state\r\n    osnap_mode = doc.header.get('$OSMODE', None)  # $OSMODE corresponds to the OSMODE system variable in DXF\r\n    print(f\"OSNAP mode saved: {osnap_mode}\")\r\n    # Simulate turning off OSNAP\r\n    doc.header['$OSMODE'] = 0  # Set OSMODE to 0\r\n    print(\"OSNAP mode turned off.\")\r\n# Convert the `left` value to an integer equivalent\r\ndef adjust_left_value(left):\r\n    adjusted_left = left - (left % 1.0)\r\n    return adjusted_left\r\n# Create or load a DXF document\r\nturn_off_osnap(doc)\r\n# Set and adjust the `left` variable\r\nleft = adjust_left_value(left)\r\nprint(f\"Adjusted left value: {left}\")\r\nd1 = 20  # Distance in mm\r\npta1 = (left - laslab, datum)\r\nptb1 = (left, datum - d1 * scale1)\r\n#############################################################\r\n##########################################\r\npta2 = [hpos(lbridge + laslab), datum]\r\nptb2 = [hpos(right), datum - d1 * scale1]\r\n#############################################################\r\n##########################################\r\nptc1 = [left, datum - 2 * d1 * scale1]\r\nptc2 = [hpos(right), datum - 2 * d1 * scale1]\r\nptd1 = [left, vpos(toprl)]\r\n    # Draw X-axis\r\nmsp.add_line(pta1, pta2)   \r\n    # Draw lines parallel to X-axis\r\nmsp.add_line(ptb1, ptb2)  # 20mm below\r\nmsp.add_line(ptc1, ptc2)  # 40mm below   \r\n########################## DRAWING BOUNDARY ###### POINTS\r\nprb3 = ptc2 # DRAWING BOUNDARY ###### POINTS\r\nprb4 = ptc1 # DRAWING BOUNDARY ###### POINTS\r\n    # Draw Y-axis\r\nmsp.add_line(ptc1, ptd1)      \r\n    # Add text for \"BED LEVEL\" and \"CHAINAGE\"\r\nptb3 = (left - 25 * scale1, datum - d1 * 0.5 * scale1)\r\nmsp.add_text(\"BED LEVEL\", dxfattribs={'height': 2.5 * scale1, 'insert': ptb3, 'halign': 0})   \r\nptb3 = (left - 25 * scale1, datum - d1 * 1.5 * scale1)\r\nmsp.add_text(\"CHAINAGE\", dxfattribs={'height': 2.5 * scale1, 'insert': ptb3, 'halign': 0})   \r\n    # Define half length for small lines on Y axis\r\nd2 = 2.5    \r\n    # Draw small lines on Y axis\r\nsmall_line_start = (left - d2 * scale1, datum)\r\nsmall_line_end = (left + d2 * scale1, datum)\r\nmsp.add_line(small_line_start, small_line_end)  \r\nnov = int((toprl - datum) // 1)  \r\n\r\n#######################\r\n\r\nvariable_values['yincr'] = yincr    \r\n    # Write levels on Y axis\r\nn = (nov // yincr)\r\na = 0\r\nwhile a <= n:\r\n    lvl = datum + a * yincr\r\n    b1 = \"{:.3f}\".format(lvl)  # converts lvl into fixed format like 100.000    \r\n    pta1 = [left - 13 * scale1, vpos(lvl) - 1.0 * scale1]\r\n    # Assuming you have a function or method to add text to the drawing\r\n    # Calculate the height of the text\r\n    # Calculate the height of the text    \r\n    text_height = 2.0 * scale1\r\n    # Add the text to the modelspace at the specified position\r\n    msp.add_text(b1, dxfattribs={'height': text_height, 'rotation': 0, 'insert': pta1})\r\n    small_line_start = (left - d2 * scale1, vpos(lvl))\r\n    small_line_end = (left + d2 * scale1, vpos(lvl))    \r\n    msp.add_line(small_line_start, small_line_end)\r\n    a += 1\r\n##########################################################################\r\n# Write chainages on X axis\r\nnoh = right - left\r\nn = int(noh // xincr)\r\nd4 = 2 * d1\r\nd5 = d4 - 2.0\r\nd6 = d1 + 2.0\r\nd7 = d1 - 2.0\r\nd8 = d4 - 4.0\r\nd9 = d1 - 4.0\r\nfor a in range(0, n + 2):\r\n        ch = left + a * xincr\r\n        b1 = f\"{ch:.3f}\"\r\n        # Position for chainage text\r\n        pta1 = [scale1 + hpos(ch), datum - d8 * scale1]\r\n        add_text(b1, pta1, 2.0 * scale1, 90)\r\n        pta1 = [hpos(ch), datum - d4 * scale1]\r\n        pta2 = [hpos(ch), datum - d5 * scale1]\r\n        pta3 = [hpos(ch), datum - d6 * scale1]\r\n        pta4 = [hpos(ch), datum - d7 * scale1]\r\ndef draw_line(pt1, pt2):\r\n    doc.modelspace().add_line(pt1, pt2, dxfattribs={'color': 7})\r\ndraw_line(pta1, pta2)\r\ndraw_line(pta3, pta4)\r\n###############################################################\r\n# 4.0 plotting cross section of the river and writing chainages\r\n# # Function to read variables and plot directly\r\ndef cs():\r\n    global left, hhs, d8, d9, d4, d5, d6, d7, xincr, b2, b1, ptb3, vpos\r\n    # File path to the Excel file\r\n    file_path = r'F:\\LISP 2005\\P1\\input.xlsx'\r\n    try:\r\n        # Read variable 'noch' from Sheet1\r\n        sheet1 = pd.read_excel(file_path, sheet_name=\"Sheet1\")\r\n        noch = int(sheet1.iloc[20, 0])  # Read 'noch' from A21 (index 20 for 0-based)\r\n        if not noch:\r\n            print(\"Error: 'noch' variable is missing or invalid. Exiting function.\")\r\n            return\r\n    except Exception as e:\r\n        print(f\"Error reading 'noch': {e}\")\r\n        return\r\n    try:\r\n        # Read chainages and RLs from Sheet2\r\n        sheet2 = pd.read_excel(file_path, sheet_name=\"Sheet2\")\r\n        chainages = sheet2['Chainage (x)']\r\n        rls = sheet2['RL (y)']\r\n    except Exception as e:\r\n        print(f\"Error reading Sheet2: {e}\")\r\n        return\r\n    # Initialize text labels\r\n    b2 = \"RL\"\r\n    b1 = \"CH\"\r\n    # Initialize variables\r\n    a = 1\r\n    ptb3 = None\r\n    # Loop through the data and plot immediately\r\n    for x, y in zip(chainages, rls):\r\n        try:\r\n            # Convert to float, skip invalid data\r\n            x = float(x)\r\n            y = float(y)\r\n        except ValueError:\r\n            print(f\"Invalid data found: Chainage: {x}, RL: {y}\")\r\n            continue\r\n        xx = hpos(x)\r\n        pta1 = [xx + 0.9 * scale1, datum - d8 * scale1]\r\n        pta2 = [xx + 0.9 * scale1, datum - d9 * scale1]\r\n        # Write level along x-axis\r\n        #msp.add_text(y, dxfattribs={'insert': pta2, 'height': 2 * scale1, 'rotation': 90})\r\n        # Check if chainage x is a multiplier of increment\r\n        b = (x - left) % xincr\r\n        if b != 0.0:\r\n            # Draw small lines along the X axis\r\n            pta3 = [xx, datum - d4 * scale1]\r\n            pta4 = [xx, datum - d5 * scale1]\r\n            msp.add_line(pta3, pta4)        \r\n            pta5 = [xx, datum - d6 * scale1]\r\n            pta6 = [xx, datum - d7 * scale1]\r\n            msp.add_line(pta5, pta6)\r\n            pta7 = [xx, datum - 2 * scale1]\r\n            pta8 = [xx, datum]\r\n            msp.add_line(pta7, pta8)\r\n        ptb4 = [xx, vpos(y)]\r\n        if a != 1:\r\n            # Draw connecting line between current and previous point\r\n            msp.add_line(ptb3, ptb4)\r\n        ptb3 = ptb4  # Update ptb3 for the next loop iteration\r\n        a += 1\r\n            # Draw connecting line between current and previous point        \r\n        ptb3 = ptb4  # Update ptb3 for the next loop iteration\r\n        print(f\"ptb3: {ptb3}, ptb4: {ptb4}\")\r\n        rounded_x = round(x, 2)\r\n        msp.add_text(rounded_x, dxfattribs={'height': 2 * scale1, 'insert': pta1, 'rotation': 90})                          \r\n        rounded_y = round(y, 2)\r\n        msp.add_text(rounded_y, dxfattribs={'height': 2 * scale1, 'insert': pta2, 'rotation': 90})  \r\n        a += 1\r\n# Call the function to generate the drawing\r\ncs()\r\n#################################################################\r\n# 5.3 Drawing Super Structure in elevation\r\n###################################################\r\n############################ \r\nspans = abtl        # ; starting chainage of span\r\nspane = spans + span1       #; end chainage of span    \r\nlspan = span1 \r\nrtl = df.loc[df['Variable'] == 'RTL', 'Value'].values[0]\r\nx1 = hpos(abtl)\r\ny1 = vpos(rtl)\r\nx2 = hpos(abtl + lspan) \r\ny2 = vpos(sofl)\r\npta1 = [x1 + 25.0, y1]\r\npta2 = [x2 - 25.0, y2]\r\nmsp.add_lwpolyline([pta1, [pta2[0], pta1[1]], pta2, [pta1[0], pta2[1]], pta1], close=True)\r\ng1 = msp.query('LWPOLYLINE')[-1]\r\n# Corrected array insertion\r\nnspan = int(nspan)\r\nfor i in range(nspan):\r\n    new_entity = g1.copy()\r\n    points = [(vertex[0] + i * span1 * hhs, vertex[1]) for vertex in new_entity.get_points()]\r\n    new_entity.set_points(points)\r\n    msp.add_entity(new_entity)\r\n#######################\r\n# Left Approach Slab Coordinates\r\nx1_left = hpos(abtl - laslab)  # Starting point of the left approach slab, flush with deck slab\r\nx2_left = hpos(abtl)  # End of the left approach slab (flush with expansion joint)\r\ny1_left = vpos(rtl)  # Top of the deck slab, same as RTL\r\ny2_left = vpos(rtl - apthk)  # Bottom of the approach slab, considering thickness\r\n# Draw Left Approach Slab with Expansion Joint (25 mm gap between)\r\npta1_left = [x1_left, y1_left]\r\npta2_left = [x2_left, y2_left]\r\nmsp.add_lwpolyline([pta1_left, [pta2_left[0], pta1_left[1]], pta2_left, [pta1_left[0], pta2_left[1]], pta1_left], close=True)\r\n# Right Approach Slab Coordinates\r\nx1_right = hpos(abtl + (nspan * span1))  # Starting point of the right approach slab, flush with deck slab\r\nx2_right = hpos(abtl + (nspan * span1) + laslab)  # End of the right approach slab\r\ny1_right = vpos(rtl)  # Top of the deck slab, same as RTL\r\ny2_right = vpos(rtl - apthk)  # Bottom of the approach slab, considering thickness\r\n# Draw Right Approach Slab with Expansion Joint (25 mm gap between)\r\npta1_right = [x1_right, y1_right]\r\npta2_right = [x2_right, y2_right]\r\nmsp.add_lwpolyline([pta1_right, [pta2_right[0], pta1_right[1]], pta2_right, [pta1_right[0], pta2_right[1]], pta1_right], close=True)\r\n# Draw the continuous wearing course (across all slabs)\r\n# Ensure the thickness of the expansion joint (25 mm = 0.025 m)\r\nexpansion_joint_thickness = 25 / 1000  # Convert 25 mm to meters (0.025 m)\r\n# Read the wearing course thickness from the Excel file (already in meters)\r\n# Ensure wearing course thickness (wcth) is set correctly\r\nif wcth != 0.075:\r\n    print(f\"Warning: Expected wearing course thickness of 75 mm (0.075 m), but found {wcth} meters.\")\r\n\r\n# Convert the expansion joint thickness to meters (25 mm = 0.025 m)\r\nexpansion_joint_thickness = 25 / 1000  # 25 mm = 0.025 m\r\n\r\n# Coordinates for the Wearing Course (continuous from left to right approach slabs)\r\nwearing_course_start_x = hpos(abtl - expansion_joint_thickness - laslab)  # Left end of wearing course\r\nwearing_course_end_x = hpos(abtl + (nspan * span1) + laslab + expansion_joint_thickness)  # Right end of wearing course\r\n\r\n# Adjust the Y-coordinates based on the wearing course thickness (WCTH)\r\nwearing_course_y1 = vpos(rtl)  # Top of the deck slab and approach slabs\r\nwearing_course_y2 = vpos(rtl+wcth)   # Bottom of the wearing course (adjusted by WCTH)\r\n\r\n# Print the Y-coordinates for debugging\r\nprint(\"Wearing Course Start X:\", wearing_course_start_x)\r\nprint(\"Wearing Course End X:\", wearing_course_end_x)\r\nprint(\"Wearing Course Y1:\", wearing_course_y1)\r\nprint(\"Wearing Course Y2:\", wearing_course_y2)\r\n\r\n# Draw the continuous wearing course from left to right approach slabs\r\nif wearing_course_start_x < wearing_course_end_x:\r\n    msp.add_lwpolyline([[wearing_course_start_x, wearing_course_y1], [wearing_course_end_x, wearing_course_y1]], close=False)\r\n    msp.add_lwpolyline([[wearing_course_start_x, wearing_course_y2], [wearing_course_end_x, wearing_course_y2]], close=False)\r\nelse:\r\n    print(\"Invalid coordinates: Wearing course not drawn\")\r\n    \r\nmsp.add_line((wearing_course_start_x, wearing_course_y1), \r\n              (wearing_course_start_x, wearing_course_y2))\r\n\r\nmsp.add_line((wearing_course_start_x, wearing_course_y1), \r\n              (wearing_course_end_x, wearing_course_y1))\r\n\r\nmsp.add_line((wearing_course_end_x, wearing_course_y1), \r\n              (wearing_course_end_x, wearing_course_y2))\r\n# END OF SECTION 5.3\r\n###########################################################################################  \r\n# pier caps in elevation\r\nlspan = span1\r\nnspan = int(nspan)  # Convert dynamically if it's not already an integer\r\n#############################################\r\ndef generate_pier_caps(abtl, lspan, capw, c, capt, capb, nspan, hhs):   \r\n    # Calculate x1 and x2 for the rectangle (cap width)\r\n    lspan = span1\r\n    x1 = abtl + lspan  # Starting position for the first span\r\n    capwsq = capw / c  # Cap width adjusted by divisor\r\n    x1 = x1 - (capwsq / 2)  # Adjust x1 for cap center alignment\r\n    x2 = x1 + capwsq  # Calculate x2\r\n    # Convert x1 and x2 to horizontal positions\r\n    x1 = hpos(x1)\r\n    x2 = hpos(x2)\r\n    # Convert capt and capb to vertical positions\r\n    y1 = vpos(capt)  # Top position of the cap\r\n    y2 = vpos(capb)  # Bottom position of the cap\r\n    # Define rectangle corners\r\n    pta1 = (x1, y1)  # Top-left corner\r\n    pta2 = (x2, y2)  # Bottom-right corner\r\n    # Draw rectangle to represent the cap in elevation\r\n    rect = msp.add_lwpolyline([\r\n        (pta1[0], pta1[1]),\r\n        (pta2[0], pta1[1]),\r\n        (pta2[0], pta2[1]),\r\n        (pta1[0], pta2[1])\r\n    ], close=True)\r\n    # Get the last entity (rectangle) for arraying\r\n    g2 = rect\r\n    # Create an array of spans\r\n    for i in range(1,(nspan-1)):\r\n        dx = i * lspan * hhs  # Horizontal offset for each span\r\n        msp.add_lwpolyline([\r\n            (pta1[0] + dx, pta1[1]),\r\n            (pta2[0] + dx, pta1[1]),\r\n            (pta2[0] + dx, pta2[1]),\r\n            (pta1[0] + dx, pta2[1])\r\n        ], close=True)\r\n# Generate the pier caps\r\ngenerate_pier_caps(abtl, lspan, capw, c, capt, capb, nspan, hhs)\r\n#######################################################################################\r\n# Drawing piers in elevation\r\n# Start drawing piers Start drawing piers Start drawing piers Start drawing piers Start drawing piers Start drawing piers\r\n# Start drawing pier caps\r\ncapwsb = capb / cos(radians(skew))\r\ncapwsq = capw / c  # Cap width adjusted by divisor\r\nxc = spane\r\npiertwsq = piertw / c ##### EARLIER IT WAS WRITTER AS pierstwsq = pierst\r\nx1 = xc - piertwsq / 2 # left point of pier top\r\ny1 = vpos(capt)\r\nx3 = x1 + piertwsq      # right point of pier top\r\ny2 = futrl + futd       #   pier bottom = footing RL + depth of foot\r\nofset = (capb - y2) / battr     # pier bw = ht/batter\r\nfrom math import cos, radians\r\nofsetsq = ofset / cos(radians(skew))\r\nx2 = x1 - ofsetsq\r\nx4 = x3 + ofsetsq\r\ny4 = y2\r\npta1 = [hpos(x1), vpos(capb)]\r\npta2 = [hpos(x2), vpos(y2)]\r\npta3 = [hpos(x3), vpos(capb)]\r\npta4 = [hpos(x4), vpos(y4)]\r\n# draw first pier in elevation # Draw slant/ vertical lines to represent the  in elevation\r\nmsp.add_line(pta1, pta2)\r\nmsp.add_line(pta3, pta4)\r\nptaa1 = [hpos(x2) + 50, vpos(y2) - 300]\r\n\r\n# Add a linear dimension\r\ndim = msp.add_linear_dim(\r\n    base=ptaa1,\r\n    p1=pta2,\r\n    p2=pta4,\r\n    angle=0\r\n)\r\ndim.render()  # Render the dimension for display\r\n# Draw rectangle to represent the cap in elevation\r\nrect = msp.add_lwpolyline([\r\n        pta2,\r\n        pta1,\r\n        pta3,\r\n        pta4,\r\n        pta2\r\n    ], close=True)\r\n    # Get the last entity (rectangle) for arraying\r\ng2 = rect\r\n    # Create an array of spans\r\nfor i in range(1, (nspan-1)):\r\n        dx = i * lspan * hhs  # Horizontal offset for each span ###### RAJKUMAR THIS IS IMPORTANT\r\n        msp.add_lwpolyline([\r\n        (pta2[0] + dx, pta2[1]),\r\n        (pta1[0] + dx, pta1[1]),\r\n        (pta3[0] + dx, pta3[1]),\r\n        (pta4[0] + dx, pta4[1])\r\n        ], close=True)\r\n# PIER IN ELEVATION COMPLETE ......SAME FOOTING LEVEL\r\n#################################################\r\n# 5.2 Start drawing footings in elevation\r\n###################################################\r\ndef generate_pier_footings(futw, futd, futrl, nspan):   \r\n    # Calculate x5 and x6 for the rectangle (footing width)\r\n    from math import cos, radians\r\nfutwsq = futw / cos(radians(skew))\r\nx5 = xc - futwsq / 2\r\nx6 = x5 + futwsq\r\ny6 = futrl\r\ny5 = y4\r\npta5 = [hpos(x5), vpos(y5)]\r\npta6 = [hpos(x6), vpos(y6)]\r\n# Convert x5 and x6 to horizontal positions\r\nx5 = hpos(x5)\r\nx6 = hpos(x6)\r\ny5 = futrl\r\ny6 = futd + futrl\r\n    # Convert futrl and futd to vertical positions\r\ny5 = vpos(y5)  # Top position of the footing\r\ny6 = vpos(y6)  # Bottom position of the footing\r\n    # Define rectangle corners\r\npta1 = (x5, y5)  # Top-left corner\r\npta2 = (x6, y6)  # Bottom-right corner\r\n# Draw rectangle to represent the cap in elevation\r\nrect = msp.add_lwpolyline([\r\n        (pta1[0], pta1[1]),\r\n        (pta2[0], pta1[1]),\r\n        (pta2[0], pta2[1]),\r\n        (pta1[0], pta2[1])\r\n    ], close=True)\r\n    # Get the last entity (rectangle) for arraying\r\ng2 = rect\r\n    # Create an array of spans\r\nfor i in range(1, (nspan-1)):\r\n        dx = i * lspan * hhs  # Horizontal offset for each span\r\n        msp.add_lwpolyline([\r\n            (pta1[0] + dx, pta1[1]),\r\n            (pta2[0] + dx, pta1[1]),\r\n            (pta2[0] + dx, pta2[1]),\r\n            (pta1[0] + dx, pta2[1])\r\n        ], close=True)\r\n# Generate the pier caps\r\ngenerate_pier_footings(futw, futd, futrl, nspan)\r\n##########################################################\r\n# 5.5 drawing Piers in plan\r\n###########################################################\r\ndef vpos(a):\r\n    \"\"\"Converts vertical position based on datum and scaling factor.\"\"\"\r\n    return datum + vvs * (a - datum)\r\n\r\ndef hpos(a):\r\n    \"\"\"Converts horizontal position based on left reference and scaling factor.\"\"\"\r\n    return left + hhs * (a - left)\r\n\r\ndef pt(a, b):\r\n    \"\"\"Converts given point (a, b) into a transformed graph point.\"\"\"\r\n    return (hpos(a), vpos(b))\r\n\r\nx7 = xc - futw / 2 # left top point of footing ( as if  bridge is normal) footing will be drawn as if bridge is normal and then roteted\r\nx8 = x7 + futw\r\nyc = datum - 30.0\r\ny7 = yc + futl / 2 # Right top point of footing\r\ny8 = y7 - futl\r\n######################################################################            \r\nglobal pta7, pta8  # Access the global variable\r\npta7 = None  # Declare pt19 as a global variable\r\n\r\npta7 = pt(x7, y7) # Top-left ..\r\npta8 = pt(x8, y8) # Bottom-right.\r\n# Calculate the other two points of the rectangle\r\npta7x = (pta7[0], pta8[1])  # Bottom -left ..... ADDITION BY RAJKUMAR\r\npta8x = (pta8[0], pta7[1])  # Top-right..... ADDITION BY RAJKUMAR\r\n# Add the rectangle as a polyline\r\n#############################################################################################\r\n# Define functions for each line FOR FOOTING IN PLAN\r\ndef gr1(msp, dx):\r\n    line = msp.add_line((pta7[0], pta7[1]), (pta8x[0], pta8x[1]))\r\n    return line\r\ndef gr2(msp, dx):\r\n    line = msp.add_line((pta8x[0], pta8x[1]), (pta8[0], pta8[1]))\r\n    return line\r\ndef gr3(msp, dx):\r\n    line = msp.add_line((pta8[0], pta8[1]), (pta7x[0], pta7x[1]))\r\n    return line\r\ndef gr4(msp, dx):\r\n    line = msp.add_line((pta7x[0], pta7x[1]), (pta7[0], pta7[1]))\r\n    return line\r\n# Array of drawing functions (lines)\r\ndrawing_functions = [gr1, gr2, gr3, gr4]\r\n# Loop to draw elements for each span\r\nfor i in range(1, nspan):\r\n    dx = i * lspan * hhs\r\n    for draw_func in drawing_functions:\r\n        draw_func(msp, dx)\r\n###################################################################\r\npt1 = [hpos(x7), vpos(y8)]  # FOOTING PLAN LEFT BOTTOM CORNER\r\npt2 = pta8                  # FOOTING PLAN LEFT BOTTOM CORNER\r\npt3 = [hpos(x7) + 100, vpos(y8) - 600]\r\ndimstyle = doc.dimstyles.get('Standard')  # Get the default dimension style\r\ndimstyle.dxf.dimexe = 200  # Set extension line extension\r\ndimstyle.dxf.dimexo = 400  # Set extension line offset\r\n##########RAJKUMAR SHORT***************************\r\n# Add a horizontal linear DIMENSION entity:\r\ndim = msp.add_linear_dim(\r\n    base = pt1, # location of the dimension line\r\n    p1 = pt2,  # 1st measurement point\r\n    p2 = pt3,  # 2nd measurement point\r\n    dimstyle=\"EZDXF\",  # default dimension style\r\n)\r\ndim.render()\r\nmsp.add_linear_dim(base = pt1, p1 = pt2, p2 = pt3, angle= 0).render()\r\ng3 = dim\r\n##########RAJKUMAR SHORT***************************   \r\npt1 = [hpos(x8), vpos(y7)]  \r\npt2 = pta8  \r\npt3 = [hpos(x8) + 700, vpos(y7) - 100]  \r\n##########RAJKUMAR SHORT***************************\r\n# Add a horizontal linear DIMENSION entity:\r\ndim = msp.add_linear_dim(\r\n    base = pt1, # location of the dimension line\r\n    p1=pt2,  # 1st measurement point\r\n    p2=pt3,  # 2nd measurement point\r\n    dimstyle=\"EZDXF\",  # default dimension style\r\n)\r\ndim.render()\r\nmsp.add_linear_dim(base = pt1, p1 = pt2, p2 = pt3, angle= 0).render()\r\ng4 = dim\r\n##########RAJKUMAR SHORT*************************** \r\nptc = pt(xc, yc)\r\nfrom math import radians, cos, sin\r\n# Function to rotate points around a given center\r\ndef rotate_point(x, y, cx, cy, angle):\r\n    angle = radians(angle)\r\n    x_new = (x - cx) * cos(angle) - (y - cy) * sin(angle) + cx\r\n    y_new = (x - cx) * sin(angle) + (y - cy) * cos(angle) + cy\r\n    return x_new, y_new\r\n\r\n# Calculate pier st length in skew\r\npierstsq = (pierst / c) + abs(piertw * tn)\r\n\r\n# Compute pier top and bottom points\r\nx1 = (xc - (piertw / 2)) # ; left point of pier top ( as if  bridge is normal) pier\r\nx3 = (x1 + piertw) # right point of pier top ( as if  bridge is normal)\r\nx2 = (x1 - ofset) # left point of pier bottom( as if  bridge is normal)\r\nx4 = (x3 + ofset) # right point of pier bottom ( as if  bridge is normal)\r\ny9 = (yc + (pierstsq / 2))\r\ny10 = (y9 - pierstsq)\r\n# Define points\r\n\r\npta9 = pt(x2, y9)  # LEFT TOP PIER POINT (DENOTING BOTTOM WIDTH IN PLAN)\r\npta10 = pt(x2, y10)  # LEFT BOTTOM PIER POINT (DENOTING BOTTOM WIDTH IN PLAN)\r\npta11 = pt(x1, y9) # RIGHT TOP PIER POINT (DENOTING BOTTOM WIDTH IN PLAN)\r\npta12 = pt(x1, y10) # RIGHT BOTTOM PIER POINT (DENOTING BOTTOM WIDTH IN PLAN)\r\n\r\npta13 = pt(x3, y9)\r\npta14 = pt(x3, y10)\r\npta15 = pt(x4, y9)\r\npta16 = pt(x4, y10)\r\n\r\n\r\nmsp.add_line(pta9, pta10)\r\nmsp.add_line(pta11, pta12)\r\n\r\nmsp.add_line(pta13, pta14)\r\nmsp.add_line(pta15, pta16)\r\n\r\n# Draw pier lines\r\ng1 = msp.add_line(pta9, pta10)\r\ng2 = msp.add_line(pta11, pta12)\r\ng3 = msp.add_line(pta13, pta14)\r\ng4 = msp.add_line(pta15, pta16)\r\n\r\n# Compute additional points\r\ny17 = y9 + (piertw / 2)\r\ny18 = y9 - ofset\r\ny19 = y10 - (piertw / 2)\r\ny20 = y19 - ofset\r\n\r\npta17 = pt(xc, y17)\r\npta18 = pt(xc, y18)\r\npta19 = pt(xc, y19)\r\npta20 = pt(xc, y20)\r\n##############################################################################################\r\n# Generate the FOOTING pier in plan\r\nx17 = xc - piertw / 2\r\nx18 = x17 + piertw\r\nyc = datum - 30.0\r\ny17 = yc + pierst / 2\r\ny18 = y17 - pierst\r\npta17a = [hpos(x17), vpos(y17)] # PIER LEFT TOP CORNER IN PLAN\r\npta17b = [hpos(x17 + piertw), vpos(y17)] # PIER RIGHT TOP CORNER IN PLAN\r\n\r\npta18a = [hpos(x18 - piertw), vpos(y18)] # PIER LEFT BOTTOM CORNER IN PLAN\r\npta18b = [hpos(x18), vpos(y18)] # PIER RIGHT BOTTOM CORNER IN PLAN\r\n\r\nmsp.add_line(pta17a, pta18a) # PIER LEFT LINE\r\nmsp.add_line(pta17b, pta18b) # PIER RIGHT LINE\r\n\r\n# Define points pt1, pt2, pt3 for the first section\r\n\r\npt1a = (hpos(x7), vpos(y8 + futl))  # PIER-FOOTING LEFT top CORNER IN PLAN\r\npt2a = [hpos(x7 + futw) , pt1a[1]]               # PIER-FOOTING RIGHT top CORNER IN PLAN\r\npt1b = (hpos(x7), vpos(y8))  # PIER-FOOTING LEFT BOTTOM CORNER IN PLAN\r\npt2b = [pt2a[0]  , pt1b[1]]              # PIER-FOOTING RIGHT BOTTOM CORNER IN PLAN\r\nmsp.add_lwpolyline([pt1a, pt1b, pt2b, pt2a, pt1a]) # pier footing\r\n#########################################################################################\r\nimport math\r\n\r\n###############################################################################################################\r\ndef g5(msp, dx):    \r\n    # Calculate the center and radius for the arc\r\n    center_x = (pta9[0] + dx + pta15[0] + dx) / 2\r\n    center_y = (pta9[1] + pta15[1]) / 2\r\n    center = (center_x, center_y)\r\n    \r\n    radius = sqrt((pta15[0] - pta9[0]) ** 2 + (pta15[1] - pta9[1]) ** 2) / 2\r\n    \r\n    start_angle = atan2(pta9[1] - center_y, pta9[0] + dx - center_x) * 180 / pi\r\n    end_angle = atan2(pta15[1] - center_y, pta15[0] + dx - center_x) * 180 / pi\r\n    \r\n    if start_angle > end_angle:\r\n        start_angle, end_angle = end_angle, start_angle\r\n\r\n    # Add the arc to the DXF drawing\r\n    msp.add_arc(center, radius, start_angle, end_angle)\r\n#####################################\r\n\r\n#####################################\r\ndef g6(msp, dx):\r\n    # Calculate the center and radius for the arc\r\n    center_x = (pta11[0] + dx + pta13[0] + dx) / 2\r\n    center_y = (pta11[1] + pta13[1]) / 2\r\n    center = (center_x, center_y)\r\n    \r\n    radius = sqrt((pta13[0] - pta11[0]) ** 2 + (pta13[1] - pta11[1]) ** 2) / 2\r\n    \r\n    start_angle = atan2(pta11[1] - center_y, pta11[0] + dx - center_x) * 180 / pi\r\n    end_angle = atan2(pta13[1] - center_y, pta13[0] + dx - center_x) * 180 / pi\r\n    \r\n    if start_angle > end_angle:\r\n        start_angle, end_angle = end_angle, start_angle\r\n    \r\n    arc = msp.add_arc(center, radius, start_angle, end_angle)\r\n    return arc\r\n\r\ndef g7(msp, dx):\r\n    # Calculate the center and radius for the arc\r\n    center_x = (pta12[0] + dx + pta14[0] + dx) / 2\r\n    center_y = (pta12[1] + pta14[1]) / 2\r\n    center = (center_x, center_y)\r\n    \r\n    radius = sqrt((pta14[0] - pta12[0]) ** 2 + (pta14[1] - pta12[1]) ** 2) / 2\r\n    \r\n    start_angle = atan2(pta12[1] - center_y, pta12[0] + dx - center_x) * 180 / pi\r\n    end_angle = atan2(pta14[1] - center_y, pta14[0] + dx - center_x) * 180 / pi\r\n    \r\n    if start_angle < end_angle:\r\n        start_angle, end_angle = end_angle, start_angle\r\n    \r\n    arc = msp.add_arc(center, radius, start_angle, end_angle)\r\n    return arc\r\n# Arc 4 (g8)\r\ndef g8(msp, dx):\r\n    # Calculate the center and radius for the arc\r\n    center_x = (pta10[0] + dx + pta16[0] + dx) / 2\r\n    center_y = (pta10[1] + pta16[1]) / 2\r\n    center = (center_x, center_y)\r\n    \r\n    radius = sqrt((pta16[0] - pta10[0]) ** 2 + (pta16[1] - pta10[1]) ** 2) / 2\r\n    \r\n    start_angle = atan2(pta10[1] - center_y, pta10[0] + dx - center_x) * 180 / pi\r\n    end_angle = atan2(pta16[1] - center_y, pta16[0] + dx - center_x) * 180 / pi\r\n    \r\n    if start_angle < end_angle:\r\n        start_angle, end_angle = end_angle, start_angle\r\n    \r\n    arc = msp.add_arc(center, radius, start_angle, end_angle)\r\n    return arc\r\n\r\n# Array of drawing functions (arcs)\r\narc_functions = [g5, g6, g7, g8]\r\n\r\n# Loop to draw elements for each span\r\nfor i in range(nspan-1):\r\n    dx = i * lspan * hhs\r\n    for arc_func in arc_functions:\r\n        print(f\"Drawing arc with function {arc_func.__name__}\")\r\n        arc = arc_func(msp, dx)\r\n        \r\n##############################################################################\r\n\r\n#######################################################################################################################\r\n####### ARRAY FOR ALL SPANS PLAN OF PIER AND FOOTING #################################################################\r\n# Array of drawing functions (G1 to G8)\r\n# Define each drawing function (g1 to g8) using msp (model space) and dx (horizontal offset)\r\n# Loop to draw elements for each span\r\nfor i in range(nspan-1):\r\n    dx = i * lspan * hhs\r\n    for draw_func in drawing_functions:\r\n        draw_func(msp, dx)\r\ndef gr1(msp, dx):\r\n    gr1 = msp.add_line((pta7[0] + dx, pta7[1]), (pta8x[0] + dx, pta8x[1]))\r\n    return gr1\r\n\r\ndef gr2(msp, dx):\r\n    gr2 = msp.add_line((pta8x[0] + dx, pta8x[1]), (pta8[0] + dx, pta8[1]))\r\n    return gr2\r\n\r\ndef gr3(msp, dx):\r\n    gr3 = msp.add_line((pta8[0] + dx, pta8[1]), (pta7x[0] + dx, pta7x[1]))\r\n    return gr3\r\n\r\ndef gr4(msp, dx):\r\n    gr4 = msp.add_line((pta7x[0] + dx, pta7x[1]), (pta7[0] + dx, pta7[1]))\r\n    return gr4\r\n        \r\ndef g1(msp, dx):\r\n    rectg1 = msp.add_line((pta9[0] + dx, pta9[1]), (pta10[0] + dx, pta10[1]))\r\n    return g1\r\n# g2: Line (example)\r\ndef g2(msp, dx):\r\n    g2 = msp.add_line((pta11[0] + dx, pta11[1]), (pta12[0] + dx, pta12[1]))\r\n    return g2\r\n# g3: Line (example)\r\ndef g3(msp, dx):\r\n    g3 = msp.add_line((pta13[0] + dx, pta13[1]), (pta14[0] + dx, pta14[1]))\r\n    return g3\r\n# g4: Line (example)\r\ndef g4(msp, dx):\r\n    g4 = msp.add_line((pta15[0] + dx, pta15[1]), (pta16[0] + dx, pta16[1]))\r\n    return g4\r\n\r\n# Define the function for each arc\r\ndef draw_arc(msp, pta_start, pta_end, dx):\r\n    # Calculate center and radius for the arc\r\n    center = ((pta_start[0] + pta_end[0]) / 2 + dx, (pta_start[1] + pta_end[1]) / 2)\r\n    radius = sqrt((pta_end[0] - pta_start[0]) ** 2 + (pta_end[1] - pta_start[1]) ** 2) / 2\r\n    \r\n    # Compute angles for counterclockwise semicircle\r\n    start_angle = atan2(pta_start[1] - center[1], pta_start[0] - center[0]) * 180 / pi\r\n    end_angle = atan2(pta_end[1] - center[1], pta_end[0] - center[0]) * 180 / pi\r\n    \r\n    # Ensure correct counterclockwise order\r\n    if start_angle > end_angle:\r\n        start_angle, end_angle = end_angle, start_angle\r\n    \r\n    # Add the arc to the DXF drawing\r\n    arc = msp.add_arc(center, radius, start_angle, end_angle)\r\n    return arc\r\n###############################################################################################################\r\n\r\n    \r\n\r\n\r\n# Array of drawing functions (arcs)\r\narc_functions = [g5, g6, g7, g8]\r\n# Array of drawing functions (g1 to g8)\r\ndrawing_functions = [g1, g2, g3, g4, gr1, gr2, gr3, gr4, g5, g6, g7, g8]\r\n# Loop to draw elements for each span\r\nfor i in range(1, nspan):  # Looping through spans, nspan - 1 intervals\r\n    dx = (i - 1) * lspan * hhs  # Calculate the horizontal offset for the current span\r\n    # Loop through each drawing function in the array and draw the element\r\n    for draw_func in drawing_functions:\r\n        draw_func(msp, dx)\r\n\r\n####################################################################\r\n\r\n#########################################################################################################################\r\n# 5.5  drawing SS of last span\r\n# Last span drawing\r\nx1 = hpos(spane)\r\ny1 = vpos(rtl)\r\nx2 = hpos(abtl + lbridge)\r\ny2 = vpos(sofl)\r\npta1 = (x1 + 25.0, y1)\r\npta2 = (x2 - 25.0, y2)\r\n# Draw last span rectangle\r\nmsp.add_lwpolyline([pta1, (pta1[0], pta2[1]), pta2, (pta2[0], pta1[1]), pta1]) #completed drwing  reactangle to represent SS last span\r\nx4 = (x1 * 2)\r\npta1 = (x1, y1)\r\npta2 = (x4, y1)\r\n# Add dimension for last span\r\nptaa1 = (x1 + span1 /2, y1 + 200)\r\n\r\n### SPAN DIMENSION SHOWING BELOW\r\n# Add a linear dimension\r\ndim = msp.add_linear_dim(\r\n    base=ptaa1,\r\n    p1=pta1,\r\n    p2=pta2,\r\n    angle=0,    \r\n)\r\ndim.render()  # Render the dimension for display\r\n    # Create an array of spans\r\nfor i in range(1, (nspan-1)):\r\n        dx = i * lspan * hhs  # Horizontal offset for each span\r\n        msp.add_lwpolyline([\r\n            (pta1[0] + dx, pta1[1]),\r\n            (pta2[0] + dx, pta1[1]),\r\n            (pta2[0] + dx, pta2[1]),\r\n            (pta1[0] + dx, pta2[1])\r\n        ], close=True)\r\n# Super Structure in Elevation complete.\r\n###########################################################\r\n\r\n\r\n\r\n\r\n####################################################################################################################################\r\n\r\n#########################################################################################################################################\r\n#5.6  NOW DRAWiNG ELEVATION AND SECTION YY OF PIER IN DOUBLE OR SCALE1/SCALE2 SCALE. ; \r\n#SIDE VIEW MODIFIED FOR HPOS VPOS BY RAJKUMAR \r\n##### offset_x = 45000 - xp  # MENTIONED AT RELEVANT PLACE\r\n#### offset_y = 90000 - yp  # MENTIONED AT RELEVANT PLACE\r\n##########################################################################\r\n##### ADD OFFSET SIDE ELEVATION\r\n# Define the translation offset\r\nrtl2 = rtl - (30 * sc) #this the level used as RTL in  drawing section. i.e. dist btween datum level and sections top on paper is 15m\r\nxp = left + span1 * nspan\r\nyp = rtl2\r\nr = 2 * span1 * nspan * scale1\r\noffset_x = r - xp  # Adjust this based on your reference point\r\noffset_y =  r - yp  # Adjust this based on your reference point\r\n#########################################################################\r\nimport pandas as pd\r\ndef get_value(df, variable_name):\r\n    return df.loc[df['Variable'] == variable_name, 'Value'].values[0]\r\n# Retrieve specific variables\r\ncapw = get_value(df, 'CAPW')\r\nccbr = get_value(df, 'CCBR')\r\nkerbw = get_value(df, 'KERBW')\r\nlbridge = get_value(df, 'LBRIDGE')\r\nnspan = get_value(df, 'NSPAN')\r\nspan1 = get_value(df, 'SPAN1')\r\nslbthe = get_value(df, 'SLBTHE')\r\nslbtht = get_value(df, 'SLBTHT')\r\nkerbd = get_value(df, 'KERBD')\r\n# Print values for validation\r\nprint(f\"CAPW: {capw}, CCBR: {ccbr}, KERBW: {kerbw}, LBRIDGE: {lbridge}, NSPAN: {nspan}, SPAN1: {span1}, SLABTHE: {slbthe}, SLABTHT: {slbtht}\")  \r\nimport math\r\ndef vpos(a):\r\n    return datum + vvs * (a - datum)   \r\ndef hpos(a):\r\n    return left + hhs * (a - left)\r\n# Define the pt function\r\ndef pt(a, b, z):\r\n    \r\n    # Convert x-coordinate to graph position\r\n    aa = hpos(a)\r\n\r\n    # Convert y-coordinate to graph position\r\n    bb = vpos(b)\r\n\r\n    # Create a list with the converted x and y coordinates\r\n    z = [aa, bb]\r\n\r\n    return z  # Return the converted point\r\n\r\n# Define values for a, b, and z\r\n#xd = left + span1 * nspan\r\n#yd = rtl\r\n#pta1 =(xd, yd)\r\npta1 = (100,0)\r\nnn1 = pta1\r\n# Assign nn1 values to a and b\r\na = nn1[0]  # First element of nn1\r\nb = nn1[1]  # Second element of nn1\r\nz = None  # Placeholder for the result\r\n# Call the pt function with valid arguments\r\nz = pt(a, b, z)\r\npta1 = pt(nn1[0], nn1[1], pta1)\r\n#########################################################\r\ndef p2t(a, b, z):\r\n    \r\n    # Set aa to the value of a\r\n    aa = a\r\n\r\n    # Convert x-coordinate to graph position using h2pos\r\n    aa = h2pos(aa)\r\n\r\n    # Set bb to the value of b\r\n    bb = b\r\n\r\n    # Convert y-coordinate to graph position using v2pos\r\n    bb = v2pos(bb)\r\n\r\n    # Create a list with the converted x and y coordinates\r\n    z = [aa, bb]\r\n\r\n    return z  # Return the converted point\r\n# End of p2t function\r\npta2 = None  # Placeholder for the resulting converted point\r\npta2 = p2t(nn1[0], nn1[1], pta2)\r\n# Output the result\r\nprint(f\"Converted point: {pta2}\")  # Output: Converted point: [converted_x, converted_y]\r\n###################################################\r\n# pta1 is last span deck slab point \r\nptnn1 = pta1 ############## very imprortant\r\n\r\npta1 = (0,0)\r\nptnn1 = pta1 ############## very imprortant\r\npta1 = pt(nn1[0], nn1[1], pta1)                     #(setq pta1 (pt (car nn1) (cadr nn1) pta1))\r\nrtl2 = rtl - (30 * sc) #this the level used as RTL in  drawing section. i.e. dist btween datum level and sections top on paper is 15m\r\n# xp and yp are defined above ##\r\nccbrsq = ccbr / c\r\nxp1 = xp + ccbrsq / 2\r\nyp1 = yp\r\nppt1 = (xp1, yp1)\r\nppt1 = p2t(xp1, yp1, ppt1)\r\nxp2 = xp + ccbrsq\r\nyp2 = yp\r\nppt2 = [xp2, yp2]\r\nppt2 = p2t(xp2, yp2, ppt2)\r\nkerbwsq = kerbw / c\r\n\r\nxp3 = xp + ccbrsq + kerbwsq\r\nyp3 = yp + slbthe - slbtht\r\nppt3 = (xp3, yp3)\r\nppt3 = p2t(xp3, yp3, ppt3)\r\n\r\nxp4 = xp + ccbrsq + kerbwsq\r\nyp4 = yp + slbthe\r\nppt4 = (xp4, yp4)\r\nppt4 = p2t(xp4, yp4, ppt4)\r\n\r\nxp5 = xp + ccbrsq + kerbwsq\r\nyp5 = yp + slbthe + kerbd\r\nppt5 = (xp5, yp5)\r\nppt5 = p2t(xp5, yp5, ppt5)\r\n\r\nk1 = 0.05 /c  #####50 and 25 mm dist is converted  into skew direction\r\nk2 = 0.025 / c\r\n\r\nxp6 = xp + ccbrsq + k1\r\nyp6 = yp + slbthe + kerbd\r\nppt6 = (xp6, yp6)\r\nppt6 = p2t(xp6, yp6, ppt6)\r\n\r\nxp7 = xp + ccbrsq + k2\r\nyp7 = yp + slbthe + kerbd - 0.025\r\nppt7 = (xp7, yp7)\r\nppt7 = p2t(xp7, yp7, ppt7)\r\n\r\nxp8 = xp + ccbrsq\r\nyp8 = yp + slbthe\r\nppt8 = (xp8, yp8)\r\nppt8 = p2t(xp8, yp8, ppt8)\r\n\r\nxp9 = xp + ccbrsq / 2\r\nyp9 = yp + slbthe\r\nppt9 = (xp9, yp9)\r\nppt9 = p2t(xp9, yp9, ppt9)\r\n\r\nxp10 = xp\r\nyp10 = yp + slbthe\r\nppt10 = (xp10, yp10)\r\nppt10 = p2t(xp10, yp10, ppt10)\r\n\r\nxp11 = xp - k2\r\nyp11 = yp + slbthe + kerbd - 0.025\r\nppt11 = (xp11, yp11)\r\nppt11 = p2t(xp11, yp11, ppt11)\r\n\r\nxp12 = xp - k1\r\nyp12 = yp + slbthe + kerbd\r\nppt12 = (xp12, yp12)\r\nppt12 = p2t(xp12, yp12, ppt12)\r\n\r\nxp13 = xp - kerbwsq\r\nyp13 = yp + slbthe + kerbd\r\nppt13 = (xp13, yp13)\r\nppt13 = p2t(xp13, yp13, ppt13)\r\n\r\nppt14 = (ppt13[0], ppt4[1]) # NO p2t function required for ppt 14 and 15. PLEASE NOTE\r\nppt15 = (ppt13[0], ppt3[1])\r\n#########################################################\r\n\r\ndiff = (pierstsq - ccbrsq) \r\ndiff = diff / 2\r\nxp = xp - diff\r\npedstl = sofl - capt\r\nyp = yp - pedstl\r\nxp16 = xp\r\nyp16 = yp\r\nppt16 = (xp16, yp16)\r\nppt16 = p2t(xp16, yp16, ppt16)\r\n\r\ncapd = capt - capb\r\nxp17 = xp - capw / 2\r\nyp17 = yp\r\nppt17 = (xp17, yp17)\r\nppt17 = p2t(xp17, yp17, ppt17)\r\n\r\nxp18 = xp + pierstsq + capw / 2\r\nyp18 = yp\r\nppt18 = (xp18, yp18)\r\nppt18 = p2t(xp18, yp18, ppt18)\r\n\r\nxp19 = xp - capw / 2\r\nyp19 = yp - capd\r\nppt19 = (xp19, yp19)\r\nppt19 = p2t(xp19, yp19, ppt19)\r\n\r\nxp20 = xp + pierstsq + capw / 2\r\nyp20 = yp - capd\r\nppt20 = (xp20, yp20)\r\nppt20 = p2t(xp20, yp20, ppt20)\r\n######################################################\r\n\r\nxp21 = xp - piertw / 2\r\nyp21 = yp - capd\r\nppt21 = (xp21, yp21)\r\nppt21 = p2t(xp21, yp21, ppt21)\r\n\r\nxp22 = xp\r\nyp22 = yp - capd\r\nppt22 = (xp22, yp22)\r\nppt22 = p2t(xp22, yp22, ppt22)\r\n\r\nxp23 = xp + pierstsq\r\nyp23 = yp - capd\r\nppt23 = (xp23, yp23)\r\nppt23 = p2t(xp23, yp23, ppt23)\r\n\r\nxp24 = xp + pierstsq + piertw / 2\r\nyp24 = yp - capd\r\nppt24 = (xp24, yp24)\r\nppt24 = p2t(xp24, yp24, ppt24)\r\n\r\nxpc = xp + pierstsq / 2\r\npierht = capb - futrl - futd\r\npierbw = pierht / battr\r\npierbw += pierbw + piertw\r\nh1 = yp - pierht + capd\r\n\r\nxpc25 = xpc - futl / 2\r\nh125 = h1\r\nppt25 = (xpc25, h125)\r\nppt25 = p2t(xpc25, h125, ppt25)\r\n\r\nxp26 = xp - pierbw / 2\r\nh126 = h1\r\nppt26 = (xp26, h126)\r\nppt26 = p2t(xp26, h126, ppt26)\r\n\r\nxp27 = xp\r\nh127 = h1\r\nppt27 = (xp27, h127)\r\nppt27 = p2t(xp27, h127, ppt27)\r\n\r\nxp28 = xp + pierstsq\r\nh128 = h1\r\nppt28 = (xp28, h128)\r\nppt28 = p2t(xp28, h128, ppt28)\r\n\r\nxp29 = xp + pierstsq + pierbw / 2\r\nh129 = h1\r\nppt29 = (xp29, h129)\r\nppt29 = p2t(xp29, h129, ppt29)\r\n\r\nxpc30 = xpc + futl / 2\r\nh130 = h1\r\nppt30 = (xpc30, h130)\r\nppt30 = p2t(xpc30, h130, ppt30)\r\n\r\n\r\n\r\nh2 = h1 - futd\r\nxpc31 = xpc - futl / 2\r\nh231 = h2\r\nppt31 = (xpc31, h231)\r\nppt31 = p2t(xpc31, h231, ppt31)\r\n\r\nxpc32 = xpc\r\nh232 = h2\r\nppt32 = (xpc32, h232)\r\nppt32 = p2t(xpc32, h232, ppt32)\r\n\r\nxpc33 = xpc + futl / 2\r\nh233 = h2\r\nppt33 = (xpc33, h233)\r\nppt33 = p2t(xpc33, h233, ppt33)\r\n\r\nxp2 = xp + ccbrsq + diff + diff\r\nyp2 = yp\r\nppt2 = (xp2, yp2)\r\nppt2 = p2t(xp2, yp2, ppt2) # NO p2t function required for ppt2 AGAIN. PLEASE NOTE\r\n\r\n#########################################################\r\n# Adjust all points by the offset\r\ndef translate_point(point, offset_x, offset_y):\r\n    return (point[0] + offset_x, point[1] + offset_y)\r\n# Translate points\r\nppt1 = translate_point(ppt1, offset_x, offset_y)\r\nppt2 = translate_point(ppt2, offset_x, offset_y)\r\nppt3 = translate_point(ppt3, offset_x, offset_y)\r\nppt4 = translate_point(ppt4, offset_x, offset_y)\r\nppt5 = translate_point(ppt5, offset_x, offset_y)\r\nppt6 = translate_point(ppt6, offset_x, offset_y)\r\nppt7 = translate_point(ppt7, offset_x, offset_y)\r\nppt8 = translate_point(ppt8, offset_x, offset_y)\r\nppt9 = translate_point(ppt9, offset_x, offset_y)\r\nppt10 = translate_point(ppt10, offset_x, offset_y)\r\nppt11 = translate_point(ppt11, offset_x, offset_y)\r\nppt12 = translate_point(ppt12, offset_x, offset_y)\r\nppt13 = translate_point(ppt13, offset_x, offset_y)\r\nppt14 = translate_point(ppt14, offset_x, offset_y)\r\nppt15 = translate_point(ppt15, offset_x, offset_y)\r\nppt16 = translate_point(ppt16, offset_x, offset_y)\r\n# Drawing kerb and carriage way in cross section\r\n# DRAWING KERB AND CARRIAGE WAY IN CROSS SECTION\r\nmsp.add_lwpolyline([ppt16, ppt1, ppt2, ppt3, ppt4, ppt5, ppt6, ppt7, ppt8, ppt9, ppt10, ppt11, ppt12, ppt13, ppt14, ppt15, ppt16], close=True)\r\nmsp.add_line(ppt14, ppt10)\r\nmsp.add_line(ppt8, ppt4)\r\n\r\nppt17 = translate_point(ppt17, offset_x, offset_y)\r\nppt18 = translate_point(ppt18, offset_x, offset_y)\r\nppt19 = translate_point(ppt19, offset_x, offset_y)\r\nppt20 = translate_point(ppt20, offset_x, offset_y)\r\nppt21 = translate_point(ppt21, offset_x, offset_y)\r\nppt22 = translate_point(ppt22, offset_x, offset_y)\r\nppt23 = translate_point(ppt23, offset_x, offset_y)\r\nppt24 = translate_point(ppt24, offset_x, offset_y)\r\nppt25 = translate_point(ppt25, offset_x, offset_y)\r\nppt26 = translate_point(ppt26, offset_x, offset_y)\r\nppt27 = translate_point(ppt27, offset_x, offset_y)\r\nppt28 = translate_point(ppt28, offset_x, offset_y)\r\nppt29 = translate_point(ppt29, offset_x, offset_y)\r\nppt30 = translate_point(ppt30, offset_x, offset_y)\r\nppt31 = translate_point(ppt31, offset_x, offset_y)\r\nppt32 = translate_point(ppt32, offset_x, offset_y)\r\nppt33 = translate_point(ppt33, offset_x, offset_y)\r\n\r\nmsp.add_lwpolyline([ppt17, ppt18, ppt20, ppt19, ppt17], close=True)\r\n# LEFT AND RIGHT LINES OF PIER ARE AS BELOW ..... rajkumar debugs\r\n# DRAWING PIER SIDE ELEVATION (SUB-STRUCTURE PART)\r\nmsp.add_line(ppt21, ppt26)\r\nmsp.add_line(ppt16, ppt27)\r\nmsp.add_line(ppt2, ppt28)\r\nmsp.add_line(ppt24, ppt29)\r\nmsp.add_lwpolyline([ppt25, ppt30, ppt33, ppt31, ppt25], close=True)\r\nmsp.add_line(ppt9, ppt32)\r\nmsp.add_line(ppt26, ppt29) ## RAJKUMAR TRIAL ERROR - bottom close.\r\n###################################################################################################\r\nimport math\r\n# Define the position functions\r\ndef vpos(a):\r\n    return datum + vvs * (a - datum)\r\ndef hpos(a, left):  # Add 'left' as a parameter\r\n    return left + hhs * (a - left)\r\ndef v2pos(a):\r\n    return datum + sc * vvs * (a - datum)\r\ndef h2pos(a):\r\n    return left + sc * hhs * (a - left)\r\n#################################################\r\n# Abutment drawing calculation\r\ndef abt1(datum, vvs, left, hhs, sc):\r\n    # Input values\r\n    # Calculations\r\n    abtlen = ccbrsq + kerbwsq + kerbwsq\r\n    x1 = abtl\r\n    alcwsq = alcw / 1   # c changed to 1 \r\n    x3 = x1 + alcwsq\r\n    capb = capt - alcd\r\n    p1 = (capb - alfbl) / alfb\r\n    p1sq = p1 / 1        # c changed to 1 \r\n    x5 = x3 + p1sq\r\n    p2 = (alfbl - altbl) / altb\r\n    p2sq = p2 / 1            # c changed to 1 \r\n    x6 = x5 + p2sq\r\n    alfosq = alfo / 1    # c changed to 1 \r\n    x7 = x6 + alfosq\r\n    y8 = altbl - alfd\r\n    dwthsq = dwth / 1    # c changed to 1\r\n    x14 = x1 - dwthsq\r\n    p3 = (capb - albbl) / albb\r\n    p3sq = p3 / 1        # c changed to 1\r\n    x12 = x14 - p3sq\r\n    rt1s = x12            #chainage where left return starts in elevation\r\n    x10 = x12 - alfosq\r\n    # 6.3 gives various points on elevation of abutment\r\n    # Adjust positions using hpos and vpos functions\r\n    print(\"x1:\", x1)\r\n    pt1 = (hpos(x1, left), vpos(rtl+ apthk - slbtht)) \r\n    pt2 = (hpos(x1, left), vpos(capt))\r\n    pt3 = (hpos(x3, left), vpos(capt))\r\n    pt4 = (hpos(x3, left), vpos(capb))\r\n    pt5 = (hpos(x5, left), vpos(alfbl))\r\n    pt6 = (hpos(x6, left), vpos(altbl))\r\n    pt7 = (hpos(x7, left), vpos(altbl))\r\n    pt8 = (hpos(x7, left), vpos(y8))\r\n    pt9 = (hpos(x10, left), vpos(y8))\r\n    pt10 = (hpos(x10, left), vpos(altbl))\r\n    pt11 = (hpos(x12, left), vpos(altbl))\r\n    pt12 = (hpos(x12, left), vpos(albbl))\r\n    pt13 = (hpos(x14, left), vpos(capb))\r\n    pt14 = (hpos(x14, left), vpos(rtl+ apthk - slbtht)) \r\n    pt15 = (hpos(x12, left), vpos(rtl+ apthk - slbtht)) \r\n# Print coordinates of PT1 and PT2\r\n    print(f\"Coordinates of PT1: {pt1}\")\r\n    print(f\"Coordinates of PT2: {pt2}\") \r\n    # Draw the abutment\r\n    msp.add_lwpolyline([pt1, pt2, pt3, pt4, pt5, pt6, pt7, pt8, pt9, pt10, pt11, pt12, pt13, pt14, pt1], close=True)\r\n    msp.add_line(pt13, pt4)\r\n    msp.add_line(pt10, pt7)\r\n    # note this is VERTICAL LINE EXTREME LEFT DENOTING RETURN WALL EXTENT\r\n    msp.add_line(pt12, pt15)  # Corrected line addition PT12 IS LOWER POINT PT15 IS UPPER ****** by rajkumar ******\r\n    msp.add_line(pt15, pt14)  # Corrected line addition # PT1 IS DIRT WALL EDGE ON RIVER SIDE ****** by rajkumar ******\r\n#####################################################################\r\n    # 6.4 ; drawing abutment left in plan\r\n    print(pt1, pt2, pt3, pt4, \"line1\")\r\n    print(pt4, pt6, pt7, pt8, \"line5\")\r\n    print(pt9, pt10, pt11, pt12, \"line9\")\r\n\r\n    \r\n    yc = datum - 30.0\r\n    y20 = yc + (abtlen / 2)   # gives Y ordinate on D/S of abt \r\n    y21 = y20 - abtlen          # gives y ordinate on u/s of abt \r\n    y16 = y20 + 0.15            #  gives Y ordinate on D/S of footing \r\n    y17 = y21 - 0.15            #  gives Y ordinate on U/S of footing \r\n    # Footing calculations\r\n    footl = (y16 - y17)\r\n    footl = footl / 2       #  EARLIER IGNORED\r\n    x = footl * s\r\n    y = footl * (1 - c)\r\n    # Define points for abutment footing in plan\r\n    pt16 = (hpos(x10 - x, left), vpos(y16) - y)\r\n    pt17 = (hpos(x10 + x, left), vpos(y17) + y)\r\n    pt18 = (hpos(x7 - x, left), vpos(y16) - y)\r\n    pt19 = (hpos(x7 + x, left), vpos(y17) + y)\r\n    ################################################################\r\n\r\n    ################################################################\r\n    # Draw abutment footing in plan\r\n    msp.add_lwpolyline([pt16, pt17, pt19, pt18, pt16], close=True) \r\n    # Skew adjustments for other points\r\n    xx = abtlen / 2 # due to skew, the X and Y ordinates of any point are shifted \r\n    x = xx * s\r\n    y = xx * (1 - c)\r\n    print(x, \"raj\")\r\n    print(y, \"raj\")\r\n    print(s, c, \"raj\")\r\n    y20 = y20 - y\r\n    y21 = y21 + y\r\n    pt20 = (hpos(x12 - x, left), vpos(y20))\r\n    pt21 = (hpos(x12 + x, left), vpos(y21))\r\n    pt22 = (hpos(x14 - x, left), vpos(y20))\r\n    pt23 = (hpos(x14 + x, left), vpos(y21))     \r\n    pt24 = (hpos(x1 - x, left), vpos(y20))  # Point 24\r\n    pt25 = (hpos(x1 + x, left), vpos(y21))  # Point 25\r\n    pt26 = (hpos(x3 - x, left), vpos(y20))  # Point 26\r\n    pt27 = (hpos(x3 + x, left), vpos(y21))  # Point 27\r\n    pt28 = (hpos(x5 - x, left), vpos(y20))  # Point 28\r\n    pt29 = (hpos(x5 + x, left), vpos(y21))  # Point 29\r\n    pt30 = (hpos(x6 - x, left), vpos(y20))  # Point 30\r\n    pt31 = (hpos(x6 + x, left), vpos(y21))  # Point 31\r\n    print(pt13, pt14, pt15, pt16, \"line13\")\r\n    print(pt17, pt18, pt19, pt20, \"line17\")\r\n    print(pt21, pt22, pt23, pt24, \"line21\")\r\n    print(pt25, pt26, pt27, pt28, \"line25\")\r\n    print(pt29, pt30, pt31, \"line29\")   \r\n    # Final lines to connect the points\r\n    # Add lines using the MSP (Model Space) object from ezdxf\r\n    msp.add_line(pt20, pt21)  # Line from pt20 to pt21\r\n    msp.add_line(pt22, pt23)  # Line from pt22 to pt23\r\n    msp.add_line(pt24, pt25)  # Line from pt24 to pt25\r\n    msp.add_line(pt26, pt27)  # Line from pt26 to pt27\r\n    msp.add_line(pt28, pt29)  # Line from pt28 to pt29\r\n    msp.add_line(pt30, pt31)  # Line from pt30 to pt31\r\n    msp.add_line(pt21, pt31)  # Line from pt21 to pt31\r\n    msp.add_line(pt20, pt30)  # Line from pt20 to pt30\r\n# completed drawing plan abutment left\r\n    \r\nabt1(datum, vvs, left, hhs, sc)\r\n########################################################################################################\r\n# ABUTMENT RIGHT\r\n########################################################################################################\r\ndef abt2(datum, vvs, left, hhs, sc, alcwr):  \r\n    # Calculate points for the right abutment\r\n    abtlen = ccbrsq + kerbwsq + kerbwsq   \r\n    x1 = abtl\r\n    alcwsq = alcw / 1  # c changed to 1 \r\n    x3 = x1 + alcwsq\r\n    capb = capt - alcd\r\n    yc = datum - 30.0\r\n    p1 = (capb - alfbr) / alfb \r\n    p1sq = p1 / 1  # c changed to 1 \r\n    x5 = x3 + p1sq\r\n    p2 = (alfbr - altbr) / altb\r\n    p2sq = p2 / 1  # c changed to 1 \r\n    x6 = x5 + p2sq\r\n    alfosq = alfo / 1  # c changed to 1 \r\n    x7 = x6 + alfosq\r\n    y8 = altbr - alfd\r\n    dwthsq = dwth / 1  # c changed to 1\r\n    x14 = x1 - dwthsq\r\n    p3 = (capb - albbr) / albb\r\n    p3sq = p3 / 1  # c changed to 1 \r\n    x12 = x14 - p3sq\r\n    rt1s = x12  # chainage where left return starts in elevation\r\n    x10 = x12 - alfosq\r\n    right_edge = left + lbridge\r\n# Debugging statements\r\n    print(f\"Left abutment position: {left}\")\r\n    print(f\"Bridge length (LBRIDGE): {lbridge}\")\r\n    print(f\"Right abutment edge: {right_edge}\")\r\n    # Adjust positions using hpos and vpos functions\r\n    # Note: We need to calculate the 'right' position \r\n    # by subtracting the distance from the 'right' edge of the bridge \r\n    pt1 = (hpos(right_edge - x1, left), vpos(rtl+ apthk - slbtht)) \r\n    pt2 = (hpos(right_edge - x1, left), vpos(capt))\r\n    pt3 = (hpos(right_edge - x3, left), vpos(capt))\r\n    pt4 = (hpos(right_edge - x3, left), vpos(capb))\r\n    pt5 = (hpos(right_edge - x5, left), vpos(alfbr)) \r\n    pt6 = (hpos(right_edge - x6, left), vpos(altbr)) \r\n    pt7 = (hpos(right_edge - x7, left), vpos(altbr)) \r\n    pt8 = (hpos(right_edge - x7, left), vpos(y8)) \r\n    pt9 = (hpos(right_edge - x10, left), vpos(y8)) \r\n    pt10 = (hpos(right_edge - x10, left), vpos(altbr)) \r\n    pt11 = (hpos(right_edge - x12, left), vpos(altbr)) \r\n    pt12 = (hpos(right_edge - x12, left), vpos(albbr)) \r\n    pt13 = (hpos(right_edge - x14, left), vpos(capb)) \r\n    pt14 = (hpos(right_edge - x14, left), vpos(rtl+ apthk - slbtht)) \r\n    pt15 = (hpos(right_edge - x12, left), vpos(rtl+ apthk - slbtht)) \r\n    ptplan1 = pt9\r\n    #ptplan1 = computed_value[\"ptplan1\"]\r\n    \r\n# Draw the abutment\r\n    msp.add_lwpolyline([pt1, pt2, pt3, pt4, pt5, pt6, pt7, pt8, pt9, pt10, pt11, pt12, pt13, pt14, pt1], close=True)\r\n    msp.add_line(pt13, pt4)\r\n    msp.add_line(pt10, pt7)\r\n    # Fix the add_line to pass two points, not three \r\n    # note this is VERTICAL LINE EXTREME LEFT DENOTING RETURN WALL EXTENT\r\n    msp.add_line(pt12, pt15)  # Corrected line addition PT12 IS LOWER POINT PT15 IS UPPER ****** by rajkumar ******\r\n    msp.add_line(pt15, pt14)  # Corrected line addition # PT1 IS DIRT WALL EDGE ON RIVER SIDE ****** by rajkumar ******\r\n    # Calculate remaining points for the right abutment\r\n    yc = datum - 30.0\r\n    y20 = yc + (abtlen / 2)   # gives Y ordinate on D/S of abt \r\n    y21 = y20 - abtlen          # gives y ordinate on u/s of abt \r\n    y16 = y20 + 0.15            #  gives Y ordinate on D/S of footing \r\n    y17 = y21 - 0.15            #  gives Y ordinate on U/S of footing \r\n    # Footing calculations\r\n    footl = (y16 - y17)\r\n    footl = footl / 2       #  EARLIER IGNORED\r\n    x = footl * s\r\n    y = footl * (1 - c)\r\n    pt20 = (hpos(right_edge - x12 - x, left), vpos(y20)) \r\n    pt21 = (hpos(right_edge - x12 + x, left), vpos(y21)) \r\n    pt22 = (hpos(right_edge - x14 - x, left), vpos(y20)) \r\n    pt23 = (hpos(right_edge - x14 + x, left), vpos(y21)) \r\n    ptplan4 = pt21\r\n    \r\n    ################################################\r\n    # Calculate footing points\r\n    footl = (y16 - y17) / 2\r\n    x = footl * s\r\n    y = footl * (1 - c)\r\n    pt16 = (hpos(right_edge - x10 - x, left), vpos(y16) - y) \r\n    pt17 = (hpos(right_edge - x10 + x, left), vpos(y17) + y) \r\n    pt18 = (hpos(right_edge - x7 - x, left), vpos(y16) - y) \r\n######################################################################            \r\n    global pt19  # Access the global variable\r\n    pt19 = None  # Declare pt19 as a global variable\r\n    pt19 = (hpos(right_edge - x7 + x, left), vpos(y17) + y)\r\n\r\n    \r\n    # Draw abutment footing in plan\r\n    msp.add_lwpolyline([pt16, pt17, pt19, pt18, pt16], close=True) \r\n    # Calculate remaining points\r\n    pt24 = (hpos(right_edge - x1 - x, left), vpos(y20))  # Point 24\r\n    pt25 = (hpos(right_edge - x1 + x, left), vpos(y21))  # Point 25\r\n    pt26 = (hpos(right_edge - x3 - x, left), vpos(y20))  # Point 26\r\n    pt27 = (hpos(right_edge - x3 + x, left), vpos(y21))  # Point 27\r\n    pt28 = (hpos(right_edge - x5 - x, left), vpos(y20))  # Point 28\r\n    pt29 = (hpos(right_edge - x5 + x, left), vpos(y21))  # Point 29\r\n    pt30 = (hpos(right_edge - x6 - x, left), vpos(y20))  # Point 30\r\n    pt31 = (hpos(right_edge - x6 + x, left), vpos(y21))  # Point 31\r\n\r\n    # Final lines to connect the points\r\n    msp.add_line(pt20, pt21)  # Line from pt20 to pt21\r\n    msp.add_line(pt22, pt23)  # Line from pt22 to pt23\r\n    msp.add_line(pt24, pt25)  # Line from pt24 to pt25\r\n    msp.add_line(pt26, pt27)  # Line from pt26 to pt27\r\n    msp.add_line(pt28, pt29)  # Line from pt28 to pt29\r\n    msp.add_line(pt30, pt31)  # Line from pt30 to pt31\r\n    msp.add_line(pt21, pt31)  # Line from pt21 to pt31\r\n    msp.add_line(pt20, pt30)  # Line from pt20 to \r\n    # completed drawing plan abutment Right\r\n# Save drawing to file\r\n#####Boundary References\r\nabt1(datum, vvs, left, hhs, sc)  # Generate left abutment\r\nabt2(datum, vvs, left, hhs, sc, alcw)  # Generate right abutment\r\n#################################################################################\r\n### ABUTMENT PARTS COMPLETE\r\n#################################################################################\r\n# Set up the dimension style\r\nst(doc)\r\n###################################################################################################################################\r\n##### drawing block boundary B01- ELEVATION\r\n# Initial Definitions\r\npb1 = [wearing_course_start_x, wearing_course_y1]  # Left Top\r\npb2 = [wearing_course_end_x, wearing_course_y1]    # Right Top\r\npb3 = prb3\r\npb4 = prb4\r\ndrawn_width = [pb3[0] - pb1[0]]\r\ndrawn_height = [pb1[1] - pb4[1]]\r\n# Calculate 50 mm offsets with scaling\r\nhor_offset = 15 * scale1  # Horizontal offset in the drawing\r\nver_offset = 15 * scale2  # Vertical offset in the drawing\r\n\r\n# Adjusted Coordinates for 50 mm clear boundary\r\npb1_adjusted = [pb1[0] - hor_offset, pb1[1] + ver_offset]  # Left Top (adjusted for clearance)\r\npb2_adjusted = [pb2[0] + hor_offset, pb2[1] + ver_offset]  # Right Top (adjusted for clearance)\r\npb4_adjusted = [pb1[0] - hor_offset, pb3[1] - ver_offset]   # Bottom Left (adjusted for clearance)\r\npb3_adjusted = [pb2[0] + hor_offset, pb3[1] - ver_offset]   # Bottom Right (adjusted for clearance)\r\n\r\n#mid point pb3, pb4#\r\n# Midpoint coordinates\r\nmidpoint_x = (pb4_adjusted[0] + pb3_adjusted[0]) / 2\r\nmidpoint_y = (pb4_adjusted[1] + pb3_adjusted[1]) / 2\r\n\r\nmidpoint = [midpoint_x, midpoint_y]\r\npm1 = midpoint\r\n# Add polyline with adjusted boundary points\r\nmsp.add_lwpolyline([pb1_adjusted, pb2_adjusted, pb3_adjusted, pb4_adjusted, pb1_adjusted], close=True)\r\n\r\n##############################################################################################################\r\n##### drawing block boundary B02- PLAN\r\n# Initial Definitions\r\nx1 = pb1_adjusted[0]# LEFT POINT\r\nx2 = pb2_adjusted[0]    # RIGHT POINT\r\ny1 = pta7[1] # PIER FOOTING IN PLAN TOP LEVEL >>>>>> EARLIER DECLARED GLOBAL\r\ny2 = pta8[1] # PIER FOOTING IN PLAN BOTTOM LEVEL >>>>>> EARLIER DECLARED GLOBAL\r\n### top boundary line offset\r\nt1 = y2 - (30 + futl / 2) * scale2\r\nt2 = futl * scale2\r\nprint(t1, \"t1\")\r\npb1 = (x1, y1)\r\npb4 = (x1, y2)\r\npb2 = (x2, pb1[1])\r\npb3 = (x1, pb4[1])\r\n# Dictionary to store computed values of points\r\n# Calculate 50 mm offsets with scaling\r\nhor_offset = 0 * scale1  # Horizontal offset in the drawing\r\nver_offset = 15 * scale2  # Vertical offset in the drawing\r\n\r\n# Adjusted Coordinates for 50 mm clear boundary\r\npb1_adjusted = [pb1[0] - hor_offset, pb1[1] + ver_offset]  # Left Top (adjusted for clearance)\r\npb2_adjusted = [pb2[0] + hor_offset, pb2[1] + ver_offset]  # Right Top (adjusted for clearance)\r\npb4_adjusted = [pb1[0] - hor_offset, pb3[1] - ver_offset]   # Bottom Left (adjusted for clearance)\r\npb3_adjusted = [pb2[0] + hor_offset, pb3[1] - ver_offset]   # Bottom Right (adjusted for clearance)\r\nprint(pb1_adjusted, pb2_adjusted, pb3_adjusted, pb4_adjusted, \"AAA\")\r\n#mid point pb3, pb4#\r\n# Midpoint coordinates\r\nmidpoint_x = (pb4_adjusted[0] + pb3_adjusted[0]) / 2\r\nmidpoint_y = (pb4_adjusted[1] + pb3_adjusted[1]) / 2\r\nmidpoint = [midpoint_x, midpoint_y]\r\npm2 = midpoint\r\n# Add polyline with adjusted boundary points\r\nmsp.add_lwpolyline([pb1_adjusted, pb2_adjusted, pb3_adjusted, pb4_adjusted, pb1_adjusted], close=True)\r\n###############################################################################################################################\r\n###################################################################################################################################\r\nimport ezdxf\r\n\r\ndef create_dxf_with_text():\r\n    # Get the modelspace\r\n    msp = doc.modelspace()\r\n\r\n    # Iterate through each point and text content and create the MText entity\r\n    for point, text_content in zip(points, text_contents):\r\n        msp.add_mtext(\r\n            text=text_content,\r\n            dxfattribs={\r\n                \"insert\": point,  # Insertion point (x, y)\r\n                \"char_height\": text_height,  # Text height\r\n                \"width\": text_width,  # Width factor for fitting\r\n                \"style\": text_style_name,  # Use the bold text style\r\n            },\r\n        )\r\n\r\n# Main DXF creation\r\nif __name__ == \"__main__\":\r\n    \r\n    # Define text style\r\n    text_style_name = \"PMB100\"\r\n    if text_style_name not in doc.styles:\r\n        style = doc.styles.new(name=text_style_name)\r\n        style.dxf.font = \"arialbd.ttf\"  # Set the font to Arial Bold\r\n\r\n    # Define common text attributes\r\n    text_height = 500  # Text height in mm\r\n    text_width = 30000  # Width of the text box in mm\r\n\r\n    # Define points for the text articles\r\n    datum = 0  # Assuming datum line at Y=0 in drawing\r\n    scale_factor = 1000  # Assuming scale factor\r\n    lbridge = 40 * scale_factor  # Bridge length (scaled)\r\n\r\n    # Define insertion points\r\n    points = [\r\n        (pm1[0], pm1[1] + ver_offset / 2 ),\r\n        (pm2[0], pm2[1] + ver_offset / 2),\r\n        (3 * lbridge / 4, datum - 120),\r\n        (lbridge / 2, datum - 160),\r\n        (lbridge / 2, datum - 200),\r\n    ]\r\n\r\n    # Define text contents\r\n    text_contents = [\r\n        \"T1: GENERAL ARRANGEMENT DRAWING\",\r\n        \"T2: FOOTING PLAN\",\r\n        \"T3: SECTIONAL PLAN\",\r\n        \"T4: GENERAL NOTES\",\r\n        \"T5: DESIGN PARAMETERS\",\r\n    ]\r\n\r\n    # Call the function to create text articles\r\n    \r\n\r\n    # Call the function to create text articles\r\n    create_dxf_with_text()\r\n####################################################################################################################################    \r\n\r\n\r\n###################################################################################################################################\r\ndirectory = r\"F:\\LISP 2005\\P1\"\r\nfilename = \"SUPER STRUCTURE.DXF\"\r\nfile_path = os.path.join(directory, filename)  # Define the file_path\r\n#f = open(file_path, \"r\")\r\n############### Save in Specified Directory Filename ####################\r\ndoc.saveas(os.path.join(directory, filename))\r\ndoc.saveas(\"combined_drawing.dxf\")\r\nprint(\"\\nFile combined_drawing.dxf saved in user successfully.\")\r\n#########################################################################\r\n###############################################################\r\ndef generate_tender_report(input_file, output_pdf):\r\n    \"\"\"Generate tender analysis report in PDF format (single file).\"\"\"\r\n    try:\r\n        # assume the sheet is called 'Bid Summary'\r\n        df = pd.read_excel(input_file, sheet_name='Bid Summary')\r\n\r\n        doc = SimpleDocTemplate(output_pdf, pagesize=landscape(letter))\r\n        elements = []\r\n\r\n        styles = getSampleStyleSheet()\r\n        title_style = ParagraphStyle(\r\n            'Title', parent=styles['Heading1'], fontSize=16,\r\n            spaceAfter=20, alignment=1)\r\n        elements.append(Paragraph(\"TENDER ANALYSIS REPORT\", title_style))\r\n\r\n        table_data = [df.columns.tolist()] + df.values.tolist()\r\n        table = Table(table_data)\r\n        table.setStyle(TableStyle([\r\n            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\r\n            ('TEXTCOLOR',  (0, 0), (-1, 0), colors.whitesmoke),\r\n            ('ALIGN',      (0, 0), (-1, -1), 'CENTER'),\r\n            ('FONTNAME',   (0, 0), (-1, 0), 'Helvetica-Bold'),\r\n            ('FONTSIZE',   (0, 0), (-1, 0), 10),\r\n            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\r\n            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\r\n            ('GRID',       (0, 0), (-1, -1), 1, colors.black)\r\n        ]))\r\n        elements.append(table)\r\n\r\n        doc.build(elements)\r\n        print(f\"Tender report generated: {output_pdf}\")\r\n\r\n    except Exception as e:\r\n        print(f\"Error generating tender report: {e}\")\r\n# Example usage:\r\n# generate_tender_report(\"tender_data.xlsx\", \"tender_analysis.xlsx\", \"tender_report.pdf\")\r\n\r\n# [Rest of the goodfor4.py contents would go here...]\r\n\r\n# ===========================================\r\n# 7. MAIN EXECUTION BLOCK\r\n# ===========================================\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    \r\n    # Check if running with Streamlit\r\n    if 'streamlit' in sys.modules:\r\n        run_streamlit_app()\r\n    else:\r\n        # Command-line execution\r\n        print(\"Running in command-line mode\")\r\n        \r\n        # Example file paths\r\n        input_file = \"input.xlsx\"\r\n        output_dxf = \"bridge_design.dxf\"\r\n        output_report = \"tender_analysis.pdf\"\r\n        \r\n        try:\r\n            # Read variables from Excel\r\n            df = read_variables(input_file)\r\n            if df is not None:\r\n                # Process variables and generate design\r\n                # [Add your main processing logic here]\r\n                \r\n                # Save the DXF file\r\n                doc.saveas(output_dxf)\r\n                print(f\"DXF file generated: {output_dxf}\")\r\n                \r\n                # Generate tender report\r\n                generate_tender_report(input_file, output_report)\r\n                \r\n        except Exception as e:\r\n            print(f\"Error: {e}\")\r\n            sys.exit(1)\r\n# ---------------------------------------------------------\r\n# 16. SCREEN-MODIFY INPUT MODE  (python bridge_gad_app.py)\r\n# ---------------------------------------------------------\r\nif __name__ == \"__main__\":\r\n    import tkinter as tk\r\n    from tkinter import ttk, filedialog, messagebox\r\n    import os\r\n\r\n    def draw_bridge():\r\n        \"\"\"Regenerate DXF + PDF with current entries.\"\"\"\r\n        try:\r\n            # 1. Build new DataFrame from GUI\r\n            new_df = pd.DataFrame(\r\n                [(float(v.get()), k, \"\") for k, v in entries.items()],\r\n                columns=[\"Value\", \"Variable\", \"Description\"]\r\n            )\r\n            global df\r\n            df = new_df\r\n\r\n            # 2. Re-read variables\r\n            vars = dict(zip(df['Variable'], df['Value']))\r\n            abtl   = float(vars.get('ABTL', 0))\r\n            lspan  = float(vars.get('SPAN1', 10))\r\n            nspan  = int(vars.get('NSPAN', 2))\r\n            capw   = float(vars.get('CAPW', 1.2))\r\n            capt   = float(vars.get('CAPT', 110))\r\n            capb   = float(vars.get('CAPB', 109.4))\r\n            futw   = float(vars.get('FUTW', 4.5))\r\n            futd   = float(vars.get('FUTD', 1.5))\r\n            futrl  = float(vars.get('FUTRL', 100))\r\n            hhs    = 1\r\n\r\n            # 3. Clear previous drawing & re-draw\r\n            doc.entities.clear()\r\n            generate_pier_caps(abtl, lspan, capw, capt, capb, nspan, hhs)\r\n            generate_pier_footings(futw, futd, futrl, nspan)\r\n\r\n            # 4. Save files\r\n            dxf_path = filedialog.asksaveasfilename(\r\n                title=\"Save DXF\",\r\n                defaultextension=\".dxf\",\r\n                filetypes=[(\"DXF files\", \"*.dxf\")]\r\n            )\r\n            if dxf_path:\r\n                doc.saveas(dxf_path)\r\n            pdf_path = filedialog.asksaveasfilename(\r\n                title=\"Save Tender PDF\",\r\n                defaultextension=\".pdf\",\r\n                filetypes=[(\"PDF files\", \"*.pdf\")]\r\n            )\r\n            if pdf_path:\r\n                generate_tender_report(\"input.xlsx\", pdf_path)\r\n            messagebox.showinfo(\"Done\", \"Files saved successfully!\")\r\n        except Exception as e:\r\n            messagebox.showerror(\"Error\", str(e))\r\n\r\n    # Create Tkinter window\r\n    root = tk.Tk()\r\n    root.title(\"Bridge Parameter Modifier\")\r\n    root.geometry(\"400x800\")\r\n\r\n    # Read original variables (or use defaults)\r\n    try:\r\n        df = read_variables(\"input.xlsx\")\r\n    except:\r\n                df = pd.DataFrame([\r\n            [186, \"SCALE1\", \"Scale1\"],\r\n            [12.00, \"ABTLEN\", \"Length Of Abutment Along Current Direction at cap level\"],\r\n            [0.30, \"DWTH\", \"Dirtwall Thickness\"],\r\n            [0.75, \"ALCW\", \"Abutment Left Cap Width Excluding D/W\"],\r\n            [100.00, \"ALFL\", \"Abutment Left Footing Level\"],\r\n            [100.75, \"ARFL\", \"Abutment RIGHT Footing Level\"],\r\n            [1.20, \"ALCD\", \"Abutment Left Cap Depth\"],\r\n            [10.00, \"ALFB\", \"Abt Left Front Batter (1 HOR : 10 VER)\"],\r\n            [101.00, \"ALFBL\", \"Abt Left Front Batter RL\"],\r\n            [100.75, \"ALFBR\", \"Abt RIGHT Front Batter RL\"],\r\n            [10.00, \"ALTB\", \"Abt Left Toe Batter (1 HOR : 5 VER)\"],\r\n            [101.00, \"ALTBL\", \"Abt Left Toe Batter Level Footing Top\"],\r\n            [100.75, \"ALTBR\", \"Abt RIGHT Toe Batter Level Footing Top\"],\r\n            [1.50, \"ALFO\", \"Abutment Left Front Offset To Footing\"],\r\n            [1.00, \"ALFD\", \"Abt Left Footing Depth\"],\r\n            [3.00, \"ALBB\", \"Abt Left Back Batter\"],\r\n            [101.00, \"ALBBL\", \"Abt Left Back Batter RL\"],\r\n            [100.75, \"ALBBR\", \"Abt RIGHT Back Batter RL\"],\r\n            [100, \"SCALE2\", \"Scale2\"],\r\n            [0.00, \"SKEW\", \"Degree Of Skew In Plan Of The Bridge\"],\r\n            [100.00, \"DATUM\", \"Datum\"],\r\n            [110.98, \"TOPRL\", \"Top RL Of The Bridge\"],\r\n            [0.00, \"LEFT\", \"Left Most Chainage Of The Bridge\"],\r\n            [43.20, \"RIGHT\", \"Right Most Chainage Of The Bridge\"],\r\n            [10.00, \"XINCR\", \"Chainage Increment In X Direction\"],\r\n            [1.00, \"YINCR\", \"Elevation Increment In Y Direction\"],\r\n            [21, \"NOCH\", \"Total No. Of Chainages On C/S\"],\r\n            [4, \"NSPAN\", \"Number of Spans\"],\r\n            [43.20, \"LBRIDGE\", \"Length Of Bridge\"],\r\n            [0.00, \"ABTL\", \"Read Chainage Of Left Abutment\"],\r\n            [110.98, \"RTL\", \"Road Top Level\"],\r\n            [110.00, \"SOFL\", \"Soffit Level\"],\r\n            [0.23, \"KERBW\", \"Width Of Kerb At Deck Top\"],\r\n            [0.23, \"KERBD\", \"Depth Of Kerb Above Deck Top\"],\r\n            [11.10, \"CCBR\", \"Clear Carriageway Width Of Bridge\"],\r\n            [0.90, \"SLBTHC\", \"Thickness Of Slab At Centre\"],\r\n            [0.75, \"SLBTHE\", \"Thickness Of Slab At Edge\"],\r\n            [0.75, \"SLBTHT\", \"Thickness Of Slab At Tip\"],\r\n            [110.00, \"CAPT\", \"Pier Cap Top RL\"],\r\n            [109.40, \"CAPB\", \"Pier Cap Bottom RL = Pier Top\"],\r\n            [1.20, \"CAPW\", \"Cap Width\"],\r\n            [1.20, \"PIERTW\", \"Pier Top Width\"],\r\n            [10.00, \"BATTR\", \"Pier Batter\"],\r\n            [12.00, \"PIERST\", \"Straight Length Of Pier\"],\r\n            [1.00, \"PIERN\", \"Sr No Of Pier\"],\r\n            [10.80, \"SPAN1\", \"Span Individual Length\"],\r\n            [100.00, \"FUTRL\", \"Founding RL Of Pier Found\"],\r\n            [1.00, \"FUTD\", \"Depth Of Footing\"],\r\n            [4.50, \"FUTW\", \"Width Of Rect Footing\"],\r\n            [12.00, \"FUTL\", \"Length Of Footing Along Current Direction\"],\r\n            [12.00, \"ABTLEN\", \"Length Of abutment Along Current Direction\"],\r\n            [3.50, \"LASLAB\", \"Length of approach slab\"],\r\n            [12.00, \"APWTH\", \"Width of approach slab\"],\r\n            [0.38, \"APTHK\", \"Thickness of approach slab\"],\r\n            [0.08, \"WCTH\", \"Thickness of wearing course\"]\r\n        ], columns=[\"Value\", \"Variable\", \"Description\"])\r\n\r\n    entries = {}\r\n    entries = {}\r\n    for idx, (_, row) in enumerate(df.iterrows()):\r\n        var = row[\"Variable\"]\r\n        val = row[\"Value\"]\r\n        desc = row[\"Description\"]\r\n        \r\n        # Create label for Variable\r\n        ttk.Label(root, text=var).grid(row=idx, column=0, sticky=\"e\", padx=5, pady=2)\r\n        \r\n        # Create entry for Value\r\n        val_entry = ttk.Entry(root, width=15)\r\n        val_entry.insert(0, str(val) if pd.notnull(val) else \"\")\r\n        val_entry.grid(row=idx, column=1, padx=5, pady=2)\r\n        \r\n        # Create label for Description (non-editable)\r\n        ttk.Label(root, text=desc if pd.notnull(desc) else \"\").grid(row=idx, column=2, sticky=\"w\", padx=5, pady=2)\r\n        \r\n        # Store the Value entry\r\n        entries[var] = val_entry\r\n\r\n    # Add the Draw & Save button\r\n    ttk.Button(root, text=\"Draw & Save\", command=draw_bridge).grid(row=len(df), column=0, columnspan=2, pady=15)\r\n\r\n    root.mainloop()","size_bytes":79138},"static/css/custom.css":{"content":"/* Custom styles for Bridge Design CAD Application */\n\n:root {\n    --primary-color: #007bff;\n    --success-color: #28a745;\n    --warning-color: #ffc107;\n    --danger-color: #dc3545;\n    --info-color: #17a2b8;\n}\n\n/* General Layout */\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n}\n\n.navbar-brand {\n    font-weight: 600;\n}\n\n/* Cards and Containers */\n.card {\n    border-radius: 0.5rem;\n    border: none;\n}\n\n.card-header {\n    border-radius: 0.5rem 0.5rem 0 0 !important;\n    font-weight: 500;\n}\n\n/* File Upload Area */\n.form-control-lg {\n    border-radius: 0.375rem;\n}\n\n.form-control:focus {\n    border-color: var(--bs-primary);\n    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n}\n\n/* Progress Indicators */\n.progress {\n    height: 0.5rem;\n    border-radius: 0.25rem;\n}\n\n.progress-bar {\n    border-radius: 0.25rem;\n}\n\n/* SVG Preview */\n.svg-preview {\n    border: 2px dashed #dee2e6;\n    border-radius: 0.5rem;\n    background-color: #f8f9fa;\n    padding: 1rem;\n    min-height: 400px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.svg-preview svg {\n    max-width: 100%;\n    height: auto;\n    background: white;\n    border-radius: 0.25rem;\n    box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);\n}\n\n/* Parameter Tables */\n.table-parameters {\n    font-size: 0.9rem;\n}\n\n.table-parameters th {\n    background-color: var(--bs-light);\n    font-weight: 600;\n    border-top: none;\n}\n\n.table-parameters td {\n    vertical-align: middle;\n}\n\n/* Buttons */\n.btn {\n    border-radius: 0.375rem;\n    font-weight: 500;\n}\n\n.btn-lg {\n    padding: 0.75rem 1.5rem;\n    font-size: 1.1rem;\n}\n\n/* Icons */\n.fa-2x {\n    font-size: 2em;\n}\n\n.fa-3x {\n    font-size: 3em;\n}\n\n.fa-4x {\n    font-size: 4em;\n}\n\n/* Alert Styling */\n.alert {\n    border-radius: 0.5rem;\n    border: none;\n}\n\n.alert-success {\n    background-color: rgba(40, 167, 69, 0.1);\n    color: var(--success-color);\n}\n\n.alert-danger {\n    background-color: rgba(220, 53, 69, 0.1);\n    color: var(--danger-color);\n}\n\n.alert-warning {\n    background-color: rgba(255, 193, 7, 0.1);\n    color: #856404;\n}\n\n.alert-info {\n    background-color: rgba(23, 162, 184, 0.1);\n    color: var(--info-color);\n}\n\n/* Modal Customization */\n.modal-content {\n    border-radius: 0.5rem;\n    border: none;\n}\n\n.modal-header {\n    border-bottom: 1px solid var(--bs-border-color);\n    background-color: var(--bs-light);\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .container {\n        padding-left: 0.75rem;\n        padding-right: 0.75rem;\n    }\n    \n    .card-body {\n        padding: 1.5rem !important;\n    }\n    \n    .svg-preview {\n        min-height: 300px;\n    }\n}\n\n/* Loading States */\n.btn:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.spinner-border-sm {\n    width: 1rem;\n    height: 1rem;\n}\n\n/* Engineering-specific styling */\n.parameter-value {\n    font-family: 'Courier New', monospace;\n    font-weight: 600;\n}\n\n.engineering-grid {\n    background-image: \n        linear-gradient(rgba(0,0,0,.1) 1px, transparent 1px),\n        linear-gradient(90deg, rgba(0,0,0,.1) 1px, transparent 1px);\n    background-size: 20px 20px;\n}\n\n/* Footer */\nfooter {\n    margin-top: auto;\n}\n\n/* Custom utility classes */\n.text-monospace {\n    font-family: 'Courier New', monospace;\n}\n\n.border-dashed {\n    border-style: dashed !important;\n}\n\n.bg-pattern {\n    background-color: #f8f9fa;\n    background-image: radial-gradient(circle, #dee2e6 1px, transparent 1px);\n    background-size: 20px 20px;\n}\n","size_bytes":3481},"static/js/app.js":{"content":"// Bridge Design CAD Application JavaScript\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    \n    // File upload validation\n    const fileInput = document.getElementById('file');\n    if (fileInput) {\n        fileInput.addEventListener('change', function(e) {\n            const file = e.target.files[0];\n            if (file) {\n                validateFileUpload(file);\n            }\n        });\n    }\n    \n    // Form submission handling\n    const uploadForm = document.getElementById('uploadForm');\n    if (uploadForm) {\n        uploadForm.addEventListener('submit', function(e) {\n            handleFormSubmission(e);\n        });\n    }\n    \n    // Initialize tooltips if Bootstrap is loaded\n    if (typeof bootstrap !== 'undefined') {\n        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'));\n        var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {\n            return new bootstrap.Tooltip(tooltipTriggerEl);\n        });\n    }\n    \n    // Auto-dismiss alerts after 5 seconds\n    const alerts = document.querySelectorAll('.alert:not(.alert-permanent)');\n    alerts.forEach(function(alert) {\n        setTimeout(function() {\n            if (alert && alert.parentNode) {\n                const bsAlert = new bootstrap.Alert(alert);\n                bsAlert.close();\n            }\n        }, 5000);\n    });\n});\n\n/**\n * Validate file upload before submission\n * @param {File} file - The selected file\n */\nfunction validateFileUpload(file) {\n    const maxSize = 16 * 1024 * 1024; // 16MB\n    const allowedTypes = [\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx\n        'application/vnd.ms-excel' // .xls\n    ];\n    \n    // Check file size\n    if (file.size > maxSize) {\n        showAlert('File size exceeds 16MB limit. Please select a smaller file.', 'danger');\n        clearFileInput();\n        return false;\n    }\n    \n    // Check file type\n    if (!allowedTypes.includes(file.type)) {\n        showAlert('Invalid file type. Please select an Excel file (.xlsx or .xls).', 'danger');\n        clearFileInput();\n        return false;\n    }\n    \n    // Show file info\n    showFileInfo(file);\n    return true;\n}\n\n/**\n * Handle form submission with progress indication\n * @param {Event} e - Form submission event\n */\nfunction handleFormSubmission(e) {\n    const fileInput = document.getElementById('file');\n    const uploadBtn = document.getElementById('uploadBtn');\n    const uploadProgress = document.getElementById('uploadProgress');\n    \n    if (!fileInput.files.length) {\n        e.preventDefault();\n        showAlert('Please select a file to upload.', 'warning');\n        return false;\n    }\n    \n    // Validate file one more time\n    if (!validateFileUpload(fileInput.files[0])) {\n        e.preventDefault();\n        return false;\n    }\n    \n    // Show progress\n    if (uploadProgress) {\n        uploadProgress.style.display = 'block';\n    }\n    \n    if (uploadBtn) {\n        uploadBtn.disabled = true;\n        uploadBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Processing...';\n    }\n    \n    // Re-enable button after timeout (fallback)\n    setTimeout(function() {\n        if (uploadBtn) {\n            uploadBtn.disabled = false;\n            uploadBtn.innerHTML = '<i class=\"fas fa-cloud-upload-alt me-2\"></i>Upload and Process';\n        }\n        if (uploadProgress) {\n            uploadProgress.style.display = 'none';\n        }\n    }, 30000); // 30 seconds timeout\n}\n\n/**\n * Clear file input\n */\nfunction clearFileInput() {\n    const fileInput = document.getElementById('file');\n    if (fileInput) {\n        fileInput.value = '';\n    }\n    hideFileInfo();\n}\n\n/**\n * Show file information\n * @param {File} file - The selected file\n */\nfunction showFileInfo(file) {\n    const fileSize = (file.size / 1024 / 1024).toFixed(2);\n    const fileInfo = document.getElementById('fileInfo');\n    \n    if (fileInfo) {\n        fileInfo.innerHTML = `\n            <div class=\"alert alert-info\">\n                <i class=\"fas fa-file-excel me-2\"></i>\n                <strong>${file.name}</strong> (${fileSize} MB)\n            </div>\n        `;\n        fileInfo.style.display = 'block';\n    }\n}\n\n/**\n * Hide file information\n */\nfunction hideFileInfo() {\n    const fileInfo = document.getElementById('fileInfo');\n    if (fileInfo) {\n        fileInfo.style.display = 'none';\n    }\n}\n\n/**\n * Show alert message\n * @param {string} message - Alert message\n * @param {string} type - Alert type (success, danger, warning, info)\n */\nfunction showAlert(message, type = 'info') {\n    const alertContainer = document.getElementById('alertContainer') || document.querySelector('.container');\n    \n    if (alertContainer) {\n        const alertElement = document.createElement('div');\n        alertElement.className = `alert alert-${type} alert-dismissible fade show`;\n        alertElement.innerHTML = `\n            <i class=\"fas fa-${getAlertIcon(type)} me-2\"></i>\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        // Insert at the beginning of container\n        alertContainer.insertBefore(alertElement, alertContainer.firstChild);\n        \n        // Auto-dismiss after 5 seconds\n        setTimeout(function() {\n            if (alertElement && alertElement.parentNode) {\n                const bsAlert = new bootstrap.Alert(alertElement);\n                bsAlert.close();\n            }\n        }, 5000);\n    }\n}\n\n/**\n * Get appropriate icon for alert type\n * @param {string} type - Alert type\n * @returns {string} Icon class name\n */\nfunction getAlertIcon(type) {\n    const icons = {\n        'success': 'check-circle',\n        'danger': 'exclamation-triangle',\n        'warning': 'exclamation-triangle',\n        'info': 'info-circle'\n    };\n    return icons[type] || 'info-circle';\n}\n\n/**\n * Download file with progress indication\n * @param {string} filename - Name of file to download\n */\nfunction downloadFile(filename) {\n    const downloadBtn = document.querySelector(`[data-filename=\"${filename}\"]`);\n    \n    if (downloadBtn) {\n        const originalContent = downloadBtn.innerHTML;\n        downloadBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Downloading...';\n        downloadBtn.disabled = true;\n        \n        // Reset button after download starts\n        setTimeout(function() {\n            downloadBtn.innerHTML = originalContent;\n            downloadBtn.disabled = false;\n        }, 2000);\n    }\n}\n\n/**\n * Toggle parameter details\n */\nfunction toggleParameterDetails() {\n    const detailsContainer = document.getElementById('parameterDetails');\n    const toggleBtn = document.getElementById('toggleDetailsBtn');\n    \n    if (detailsContainer && toggleBtn) {\n        if (detailsContainer.style.display === 'none') {\n            detailsContainer.style.display = 'block';\n            toggleBtn.innerHTML = '<i class=\"fas fa-chevron-up me-2\"></i>Hide Details';\n        } else {\n            detailsContainer.style.display = 'none';\n            toggleBtn.innerHTML = '<i class=\"fas fa-chevron-down me-2\"></i>Show Details';\n        }\n    }\n}\n\n/**\n * Copy parameter value to clipboard\n * @param {string} value - Value to copy\n * @param {Element} button - Button element that triggered the action\n */\nfunction copyToClipboard(value, button) {\n    navigator.clipboard.writeText(value).then(function() {\n        const originalContent = button.innerHTML;\n        button.innerHTML = '<i class=\"fas fa-check text-success\"></i>';\n        \n        setTimeout(function() {\n            button.innerHTML = originalContent;\n        }, 1500);\n    }).catch(function(err) {\n        console.error('Could not copy text: ', err);\n        showAlert('Failed to copy to clipboard', 'danger');\n    });\n}\n\n/**\n * Format number for display\n * @param {number} value - Number to format\n * @param {number} decimals - Number of decimal places\n * @returns {string} Formatted number\n */\nfunction formatNumber(value, decimals = 2) {\n    if (typeof value !== 'number') {\n        return value;\n    }\n    return value.toFixed(decimals);\n}\n\n/**\n * Validate parameter values in real-time\n * @param {Object} parameters - Parameter object to validate\n */\nfunction validateParameters(parameters) {\n    const validationRules = {\n        'scale1': { min: 1, max: 10000, type: 'number' },\n        'scale2': { min: 1, max: 10000, type: 'number' },\n        'skew': { min: -45, max: 45, type: 'number' },\n        'nspan': { min: 1, max: 20, type: 'integer' },\n        'lbridge': { min: 1, max: 1000, type: 'number' },\n        'ccbr': { min: 1, max: 50, type: 'number' }\n    };\n    \n    const errors = [];\n    \n    for (const [param, rules] of Object.entries(validationRules)) {\n        if (parameters.hasOwnProperty(param)) {\n            const value = parameters[param];\n            \n            if (rules.type === 'number' && (isNaN(value) || !isFinite(value))) {\n                errors.push(`${param}: Must be a valid number`);\n                continue;\n            }\n            \n            if (rules.type === 'integer' && (!Number.isInteger(value) || value !== Math.floor(value))) {\n                errors.push(`${param}: Must be an integer`);\n                continue;\n            }\n            \n            if (rules.min !== undefined && value < rules.min) {\n                errors.push(`${param}: Must be at least ${rules.min}`);\n            }\n            \n            if (rules.max !== undefined && value > rules.max) {\n                errors.push(`${param}: Must be at most ${rules.max}`);\n            }\n        }\n    }\n    \n    return {\n        valid: errors.length === 0,\n        errors: errors\n    };\n}\n\n// Export functions for use in other scripts\nwindow.BridgeApp = {\n    validateFileUpload,\n    showAlert,\n    downloadFile,\n    copyToClipboard,\n    formatNumber,\n    validateParameters\n};\n","size_bytes":9880}}}